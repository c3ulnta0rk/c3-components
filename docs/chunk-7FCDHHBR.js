import {
  MatNativeDateModule
} from "./chunk-ZC4TG6JF.js";
import "./chunk-EE4HTFWV.js";
import {
  C3FileViewer,
  C3FileViewerDialogComponent,
  C3FileViewerModule,
  configDemo,
  crabbyImgs
} from "./chunk-KUO36XDT.js";
import "./chunk-ZZ5UYSMJ.js";
import {
  ComponentNavComponent
} from "./chunk-PN4CLJLJ.js";
import {
  ExampleViewerComponent,
  ExampleViewerTabComponent
} from "./chunk-LALM5A6J.js";
import "./chunk-M3WS2NE6.js";
import {
  MatButtonModule,
  MatIconButton,
  MatRippleModule,
  OverlayConfig,
  OverlayModule,
  createFlexibleConnectedPositionStrategy,
  createOverlayRef,
  createRepositionScrollStrategy
} from "./chunk-HJOU2AGX.js";
import {
  CdkScrollableModule,
  DomPortalOutlet,
  MatRipple,
  ScrollDispatcher,
  TemplatePortal,
  ViewportRuler,
  _StructuralStylesLoader,
  _animationsDisabled
} from "./chunk-HCQT5YPP.js";
import {
  HighlightJsDirective
} from "./chunk-H2OJKUSB.js";
import {
  RouterModule
} from "./chunk-DYF2Z4RC.js";
import {
  MatIcon,
  MatIconModule
} from "./chunk-XOJCRGWO.js";
import {
  DOWN_ARROW,
  Directionality,
  ENTER,
  ESCAPE,
  FocusKeyManager,
  FocusMonitor,
  LEFT_ARROW,
  MatCommonModule,
  RIGHT_ARROW,
  SPACE,
  UP_ARROW,
  _CdkPrivateStyleLoader,
  _IdGenerator,
  _getEventTarget,
  _getShadowRoot,
  hasModifierKey,
  isFakeMousedownFromScreenReader,
  isFakeTouchstartFromScreenReader
} from "./chunk-2WQUS347.js";
import {
  HttpClient
} from "./chunk-OUHP5ZTC.js";
import {
  AsyncPipe,
  CommonModule,
  DatePipe,
  NgClass,
  NgTemplateOutlet
} from "./chunk-DXGZR3PZ.js";
import {
  ApplicationRef,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ContentChild,
  ContentChildren,
  DOCUMENT,
  Directive,
  ElementRef,
  EventEmitter,
  HostListener,
  InjectionToken,
  Injector,
  Input,
  NgModule,
  NgZone,
  Output,
  QueryList,
  Renderer2,
  Subject,
  Subscription,
  TemplateRef,
  ViewChild,
  ViewContainerRef,
  ViewEncapsulation,
  __spreadProps,
  __spreadValues,
  afterNextRender,
  booleanAttribute,
  computed,
  contentChild,
  contentChildren,
  effect,
  filter,
  forwardRef,
  inject,
  input,
  merge,
  of,
  output,
  setClassMetadata,
  signal,
  skipWhile,
  startWith,
  switchMap,
  take,
  takeUntil,
  viewChild,
  ɵsetClassDebugInfo,
  ɵɵInheritDefinitionFeature,
  ɵɵProvidersFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassProp,
  ɵɵconditional,
  ɵɵconditionalCreate,
  ɵɵcontentQuery,
  ɵɵcontentQuerySignal,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdomElementEnd,
  ɵɵdomElementStart,
  ɵɵdomListener,
  ɵɵdomProperty,
  ɵɵdomTemplate,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵinvalidFactory,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnamespaceSVG,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind2,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵqueryAdvance,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵrepeater,
  ɵɵrepeaterCreate,
  ɵɵrepeaterTrackByIdentity,
  ɵɵrepeaterTrackByIndex,
  ɵɵresetView,
  ɵɵrestoreView,
  ɵɵsanitizeUrl,
  ɵɵtemplate,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵviewQuery,
  ɵɵviewQuerySignal
} from "./chunk-PMKCWKFR.js";

// projects/c3-components-docs/src/app/pages/docs/pages/file-displayer/pages/api/api.component.ts
var _ApiComponent = class _ApiComponent {
};
_ApiComponent.\u0275fac = function ApiComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ApiComponent)();
};
_ApiComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ApiComponent, selectors: [["c3-api"]], decls: 3, vars: 0, template: function ApiComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275domElementStart(0, "p");
    \u0275\u0275text(1, "api works!");
    \u0275\u0275domElementEnd();
    \u0275\u0275text(2, ",\n");
  }
}, styles: ["\n\n[_nghost-%COMP%] {\n  display: block;\n}\n/*# sourceMappingURL=api.component.css.map */"] });
var ApiComponent = _ApiComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApiComponent, [{
    type: Component,
    args: [{ selector: "c3-api", imports: [], template: "<p>api works!</p>,\n", styles: ["/* projects/c3-components-docs/src/app/pages/docs/pages/file-displayer/pages/api/api.component.scss */\n:host {\n  display: block;\n}\n/*# sourceMappingURL=api.component.css.map */\n"] }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ApiComponent, { className: "ApiComponent", filePath: "projects/c3-components-docs/src/app/pages/docs/pages/file-displayer/pages/api/api.component.ts", lineNumber: 10 });
})();

// projects/c3-components/src/lib/c3-file-displayer/c3-file-display-card/c3-file-display-card.component.ts
function C3FileDisplayCardComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 1)(1, "button", 2);
    \u0275\u0275listener("click", function C3FileDisplayCardComponent_Conditional_1_Template_button_click_1_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onDownload.emit());
    });
    \u0275\u0275elementStart(2, "mat-icon");
    \u0275\u0275text(3, "download");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(4, "button", 3);
    \u0275\u0275listener("click", function C3FileDisplayCardComponent_Conditional_1_Template_button_click_4_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onDelete.emit());
    });
    \u0275\u0275elementStart(5, "mat-icon");
    \u0275\u0275text(6, "delete");
    \u0275\u0275elementEnd()()();
  }
}
function C3FileDisplayCardComponent_Conditional_2_Case_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "img", 4);
    \u0275\u0275pipe(1, "async");
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("src", \u0275\u0275pipeBind1(1, 2, ctx_r1.getFileObjectUrl()) || "/default-image.svg", \u0275\u0275sanitizeUrl)("alt", ctx_r1.getFileName());
  }
}
function C3FileDisplayCardComponent_Conditional_2_Case_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-icon");
    \u0275\u0275text(1, " file-pdf-box ");
    \u0275\u0275elementEnd();
  }
}
function C3FileDisplayCardComponent_Conditional_2_Case_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-icon");
    \u0275\u0275text(1, " video ");
    \u0275\u0275elementEnd();
  }
}
function C3FileDisplayCardComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, C3FileDisplayCardComponent_Conditional_2_Case_0_Template, 2, 4, "img", 4)(1, C3FileDisplayCardComponent_Conditional_2_Case_1_Template, 2, 0, "mat-icon")(2, C3FileDisplayCardComponent_Conditional_2_Case_2_Template, 2, 0, "mat-icon");
    \u0275\u0275elementStart(3, "div", 5)(4, "span", 6);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    let tmp_1_0;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275conditional((tmp_1_0 = ctx_r1.getFileType()) === "image" ? 0 : tmp_1_0 === "application" ? 1 : tmp_1_0 === "video" ? 2 : -1);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate1(" ", ctx_r1.getDisplayName(), " ");
  }
}
var _C3FileDisplayCardComponent = class _C3FileDisplayCardComponent {
  constructor() {
    this.fileObjectUrl = input.required(...ngDevMode ? [{ debugName: "fileObjectUrl" }] : []);
    this.displayFn = input((file) => file.name, ...ngDevMode ? [{ debugName: "displayFn" }] : []);
    this.deletable = input(false, ...ngDevMode ? [{ debugName: "deletable" }] : []);
    this.size = input("32", ...ngDevMode ? [{ debugName: "size" }] : []);
    this.onDelete = output();
    this.onDownload = output();
    this.getFileType = computed(() => {
      const file = this.fileObjectUrl();
      if (file && file.type) {
        if (file.type.startsWith("image"))
          return "image";
        if (file.type.startsWith("application"))
          return "application";
        if (file.type.startsWith("video"))
          return "video";
      }
      return "unknown";
    }, ...ngDevMode ? [{ debugName: "getFileType" }] : []);
    this.getFileObjectUrl = computed(() => {
      const file = this.fileObjectUrl();
      return file && file.objectUrl ? file.objectUrl : null;
    }, ...ngDevMode ? [{ debugName: "getFileObjectUrl" }] : []);
    this.getFileName = computed(() => {
      const file = this.fileObjectUrl();
      return file ? this.displayFn()(file) : "";
    }, ...ngDevMode ? [{ debugName: "getFileName" }] : []);
    this.getDisplayName = computed(() => {
      const file = this.fileObjectUrl();
      return file ? this.displayFn()(file) : "";
    }, ...ngDevMode ? [{ debugName: "getDisplayName" }] : []);
  }
};
_C3FileDisplayCardComponent.\u0275fac = function C3FileDisplayCardComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _C3FileDisplayCardComponent)();
};
_C3FileDisplayCardComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _C3FileDisplayCardComponent, selectors: [["c3-file-display-card"]], inputs: { fileObjectUrl: [1, "fileObjectUrl"], displayFn: [1, "displayFn"], deletable: [1, "deletable"], size: [1, "size"] }, outputs: { onDelete: "onDelete", onDownload: "onDownload" }, decls: 3, vars: 12, consts: [[1, "file-card", "border"], [1, "actions"], ["mat-icon-button", "", 3, "click"], ["mat-icon-button", "", "color", "red", 3, "click"], [1, "h-full", "w-full", "object-cover", 3, "src", "alt"], [1, "informations", "flex", "justify-between", "items-center"], [1, "text-xs", "text-white"]], template: function C3FileDisplayCardComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "button", 0);
    \u0275\u0275conditionalCreate(1, C3FileDisplayCardComponent_Conditional_1_Template, 7, 0, "div", 1);
    \u0275\u0275conditionalCreate(2, C3FileDisplayCardComponent_Conditional_2_Template, 6, 2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275classProp("size-16", ctx.size() === "16")("size-32", ctx.size() === "32")("size-64", ctx.size() === "64")("size-128", ctx.size() === "128")("size-256", ctx.size() === "256");
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx.deletable() ? 1 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx.fileObjectUrl() ? 2 : -1);
  }
}, dependencies: [CommonModule, MatButtonModule, MatIconButton, MatIconModule, MatIcon, AsyncPipe], styles: ["\n\n[_nghost-%COMP%] {\n  display: block;\n  width: fit-content;\n}\n[_nghost-%COMP%]   .file-card[_ngcontent-%COMP%] {\n  position: relative;\n  border-radius: 4px;\n  border: 1px solid #e0e0e0;\n  overflow: hidden;\n}\n[_nghost-%COMP%]   .file-card[_ngcontent-%COMP%]   .actions[_ngcontent-%COMP%] {\n  position: absolute;\n  top: -21px;\n  right: -21px;\n  z-index: 1;\n  display: none;\n}\n[_nghost-%COMP%]   .file-card[_ngcontent-%COMP%]   img[_ngcontent-%COMP%] {\n  border-radius: 4px;\n}\n[_nghost-%COMP%]   .file-card[_ngcontent-%COMP%]:hover   .actions[_ngcontent-%COMP%] {\n  display: block;\n}\n[_nghost-%COMP%]   .file-card[_ngcontent-%COMP%]   .informations[_ngcontent-%COMP%] {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  z-index: 1;\n  width: 100%;\n  background: rgba(0, 0, 0, 0.5);\n  padding: 0 4px;\n}\n[_nghost-%COMP%]   .size-16[_ngcontent-%COMP%] {\n  height: 4rem;\n  width: 4rem;\n}\n[_nghost-%COMP%]   .size-32[_ngcontent-%COMP%] {\n  height: 8rem;\n  width: 8rem;\n}\n[_nghost-%COMP%]   .size-64[_ngcontent-%COMP%] {\n  height: 16rem;\n  width: 16rem;\n}\n[_nghost-%COMP%]   .size-128[_ngcontent-%COMP%] {\n  height: 32rem;\n  width: 32rem;\n}\n[_nghost-%COMP%]   .size-256[_ngcontent-%COMP%] {\n  height: 64rem;\n  width: 64rem;\n}\n/*# sourceMappingURL=c3-file-display-card.component.css.map */"] });
var C3FileDisplayCardComponent = _C3FileDisplayCardComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(C3FileDisplayCardComponent, [{
    type: Component,
    args: [{ selector: "c3-file-display-card", imports: [CommonModule, MatButtonModule, MatIconModule], template: `<button
  class="file-card border"
  [class.size-16]="size() === '16'"
  [class.size-32]="size() === '32'"
  [class.size-64]="size() === '64'"
  [class.size-128]="size() === '128'"
  [class.size-256]="size() === '256'"
>
  @if(deletable()) {
    <div class="actions">
      <button mat-icon-button (click)="onDownload.emit()">
        <mat-icon>download</mat-icon>
      </button>
      <button mat-icon-button color="red" (click)="onDelete.emit()">
        <mat-icon>delete</mat-icon>
      </button>
    </div>
  } @if(fileObjectUrl()) {
    @switch (getFileType()) { @case ('image') {
      <img
        class="h-full w-full object-cover"
        [src]="(getFileObjectUrl() | async) || '/default-image.svg'"
        [alt]="getFileName()"
      />
      } @case ('application') {
      <mat-icon> file-pdf-box </mat-icon>
      } @case ('video') {
      <mat-icon> video </mat-icon>
      }
    }

    <div class="informations flex justify-between items-center">
      <span class="text-xs text-white">
        {{ getDisplayName() }}
      </span>
    </div>
  }
</button>
`, styles: ["/* projects/c3-components/src/lib/c3-file-displayer/c3-file-display-card/c3-file-display-card.component.scss */\n:host {\n  display: block;\n  width: fit-content;\n}\n:host .file-card {\n  position: relative;\n  border-radius: 4px;\n  border: 1px solid #e0e0e0;\n  overflow: hidden;\n}\n:host .file-card .actions {\n  position: absolute;\n  top: -21px;\n  right: -21px;\n  z-index: 1;\n  display: none;\n}\n:host .file-card img {\n  border-radius: 4px;\n}\n:host .file-card:hover .actions {\n  display: block;\n}\n:host .file-card .informations {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  z-index: 1;\n  width: 100%;\n  background: rgba(0, 0, 0, 0.5);\n  padding: 0 4px;\n}\n:host .size-16 {\n  height: 4rem;\n  width: 4rem;\n}\n:host .size-32 {\n  height: 8rem;\n  width: 8rem;\n}\n:host .size-64 {\n  height: 16rem;\n  width: 16rem;\n}\n:host .size-128 {\n  height: 32rem;\n  width: 32rem;\n}\n:host .size-256 {\n  height: 64rem;\n  width: 64rem;\n}\n/*# sourceMappingURL=c3-file-display-card.component.css.map */\n"] }]
  }], null, { fileObjectUrl: [{ type: Input, args: [{ isSignal: true, alias: "fileObjectUrl", required: true }] }], displayFn: [{ type: Input, args: [{ isSignal: true, alias: "displayFn", required: false }] }], deletable: [{ type: Input, args: [{ isSignal: true, alias: "deletable", required: false }] }], size: [{ type: Input, args: [{ isSignal: true, alias: "size", required: false }] }], onDelete: [{ type: Output, args: ["onDelete"] }], onDownload: [{ type: Output, args: ["onDownload"] }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(C3FileDisplayCardComponent, { className: "C3FileDisplayCardComponent", filePath: "projects/c3-components/src/lib/c3-file-displayer/c3-file-display-card/c3-file-display-card.component.ts", lineNumber: 16 });
})();

// projects/c3-components/src/lib/c3-file-displayer/c3-file-display-grid/c3-file-display-grid.component.ts
function C3FileDisplayGridComponent_For_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "c3-file-display-card", 3);
    \u0275\u0275listener("click", function C3FileDisplayGridComponent_For_3_Template_c3_file_display_card_click_0_listener($event) {
      const $index_r2 = \u0275\u0275restoreView(_r1).$index;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.openDialog($event, $index_r2));
    })("onDelete", function C3FileDisplayGridComponent_For_3_Template_c3_file_display_card_onDelete_0_listener() {
      const file_r4 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onDelete.emit(file_r4));
    })("onDownload", function C3FileDisplayGridComponent_For_3_Template_c3_file_display_card_onDownload_0_listener() {
      const file_r4 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.fileViewer.download(file_r4));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const $index_r2 = ctx.$index;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("fileObjectUrl", ctx_r2.fileViewer.filesObjectUrl[$index_r2])("size", ctx_r2.cardSize());
  }
}
var _C3FileDisplayGridComponent = class _C3FileDisplayGridComponent {
  constructor() {
    this.files = input.required(...ngDevMode ? [{ debugName: "files" }] : []);
    this.config = input(...ngDevMode ? [void 0, { debugName: "config" }] : []);
    this.cardSize = input("32", ...ngDevMode ? [{ debugName: "cardSize" }] : []);
    this.displayFn = input((file) => file.name, ...ngDevMode ? [{ debugName: "displayFn" }] : []);
    this.deletable = input(false, ...ngDevMode ? [{ debugName: "deletable" }] : []);
    this.onDelete = output();
    this.dialog = viewChild(C3FileViewerDialogComponent, ...ngDevMode ? [{ debugName: "dialog" }] : []);
    this.fileViewer = new C3FileViewer({
      client: inject(HttpClient)
    });
    effect(() => {
      this.fileViewer.files = this.files();
    });
    effect(() => {
      if (this.config())
        this.fileViewer.config = this.config();
    });
  }
  openDialog($event, index) {
    $event.stopPropagation();
    this.fileViewer.currentIndex = index;
    this.dialog()?.openDialog();
  }
};
_C3FileDisplayGridComponent.\u0275fac = function C3FileDisplayGridComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _C3FileDisplayGridComponent)();
};
_C3FileDisplayGridComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _C3FileDisplayGridComponent, selectors: [["c3-file-display-grid"]], viewQuery: function C3FileDisplayGridComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuerySignal(ctx.dialog, C3FileViewerDialogComponent, 5);
  }
  if (rf & 2) {
    \u0275\u0275queryAdvance();
  }
}, inputs: { files: [1, "files"], config: [1, "config"], cardSize: [1, "cardSize"], displayFn: [1, "displayFn"], deletable: [1, "deletable"] }, outputs: { onDelete: "onDelete" }, decls: 4, vars: 1, consts: [[3, "fileViewer"], [1, "c3-file-display-grid"], [3, "fileObjectUrl", "size"], [3, "click", "onDelete", "onDownload", "fileObjectUrl", "size"]], template: function C3FileDisplayGridComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "c3-file-viewer-dialog", 0)(1, "div", 1);
    \u0275\u0275repeaterCreate(2, C3FileDisplayGridComponent_For_3_Template, 1, 2, "c3-file-display-card", 2, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275property("fileViewer", ctx.fileViewer);
    \u0275\u0275advance(2);
    \u0275\u0275repeater(ctx.files());
  }
}, dependencies: [C3FileDisplayCardComponent, C3FileViewerModule, C3FileViewerDialogComponent], styles: ["\n\n[_nghost-%COMP%] {\n  display: block;\n}\n[_nghost-%COMP%]   .c3-file-display-grid[_ngcontent-%COMP%] {\n  display: flex;\n  flex-flow: wrap;\n  gap: 1rem;\n}\n/*# sourceMappingURL=c3-file-display-grid.component.css.map */"] });
var C3FileDisplayGridComponent = _C3FileDisplayGridComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(C3FileDisplayGridComponent, [{
    type: Component,
    args: [{ selector: "c3-file-display-grid", imports: [C3FileDisplayCardComponent, C3FileViewerModule], template: '<c3-file-viewer-dialog [fileViewer]="fileViewer">\n  <div class="c3-file-display-grid">\n    @for (file of files(); track $index) {\n    <c3-file-display-card\n      [fileObjectUrl]="fileViewer.filesObjectUrl[$index]"\n      [size]="cardSize()"\n      (click)="openDialog($event, $index)"\n      (onDelete)="onDelete.emit(file)"\n      (onDownload)="fileViewer.download(file)"\n    />\n    }\n  </div>\n</c3-file-viewer-dialog>\n', styles: ["/* projects/c3-components/src/lib/c3-file-displayer/c3-file-display-grid/c3-file-display-grid.component.scss */\n:host {\n  display: block;\n}\n:host .c3-file-display-grid {\n  display: flex;\n  flex-flow: wrap;\n  gap: 1rem;\n}\n/*# sourceMappingURL=c3-file-display-grid.component.css.map */\n"] }]
  }], () => [], { files: [{ type: Input, args: [{ isSignal: true, alias: "files", required: true }] }], config: [{ type: Input, args: [{ isSignal: true, alias: "config", required: false }] }], cardSize: [{ type: Input, args: [{ isSignal: true, alias: "cardSize", required: false }] }], displayFn: [{ type: Input, args: [{ isSignal: true, alias: "displayFn", required: false }] }], deletable: [{ type: Input, args: [{ isSignal: true, alias: "deletable", required: false }] }], onDelete: [{ type: Output, args: ["onDelete"] }], dialog: [{ type: ViewChild, args: [forwardRef(() => C3FileViewerDialogComponent), { isSignal: true }] }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(C3FileDisplayGridComponent, { className: "C3FileDisplayGridComponent", filePath: "projects/c3-components/src/lib/c3-file-displayer/c3-file-display-grid/c3-file-display-grid.component.ts", lineNumber: 27 });
})();

// projects/c3-components/src/lib/c3-file-displayer/c3-file-display-icon/c3-file-display-icon.component.ts
var _C3FileDisplayIconComponent = class _C3FileDisplayIconComponent {
  constructor() {
    this.fileType = input.required(...ngDevMode ? [{ debugName: "fileType" }] : []);
    this.displayedIcon = computed(() => {
      switch (this.fileType()) {
        case "image/webp":
        case "image/png":
        case "image/jpeg":
        case "image/jpg":
          return "image";
        case "video/mp4":
        case "video/webm":
          return "play_circle";
        case "application/pdf":
          return "picture_as_pdf";
        case "application/msword":
        case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
          return "description";
        default:
          return "content_copy";
      }
    }, ...ngDevMode ? [{ debugName: "displayedIcon" }] : []);
    this.color = computed(() => {
      switch (this.fileType()) {
        case "image/webp":
        case "image/png":
        case "image/jpeg":
        case "image/jpg":
          return "text-primary";
        case "video/mp4":
        case "video/webm":
          return "text-secondary";
        case "application/pdf":
          return "text-error";
        case "application/msword":
        case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
          return "text-success";
        default:
          return "text-gray";
      }
    }, ...ngDevMode ? [{ debugName: "color" }] : []);
  }
};
_C3FileDisplayIconComponent.\u0275fac = function C3FileDisplayIconComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _C3FileDisplayIconComponent)();
};
_C3FileDisplayIconComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _C3FileDisplayIconComponent, selectors: [["c3-file-display-icon"]], inputs: { fileType: [1, "fileType"] }, decls: 2, vars: 2, consts: [[3, "ngClass"]], template: function C3FileDisplayIconComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "mat-icon", 0);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("ngClass", ctx.color());
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx.displayedIcon());
  }
}, dependencies: [CommonModule, NgClass, MatIconModule, MatIcon], styles: ["\n\n[_nghost-%COMP%] {\n  display: block;\n}\n[_nghost-%COMP%]   .text-primary[_ngcontent-%COMP%] {\n  color: var(--primary-color);\n}\n[_nghost-%COMP%]   .text-secondary[_ngcontent-%COMP%] {\n  color: var(--secondary-color);\n}\n[_nghost-%COMP%]   .text-success[_ngcontent-%COMP%] {\n  color: var(--success-color);\n}\n[_nghost-%COMP%]   .text-gray[_ngcontent-%COMP%] {\n  color: var(--gray-color);\n}\n/*# sourceMappingURL=c3-file-display-icon.component.css.map */"] });
var C3FileDisplayIconComponent = _C3FileDisplayIconComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(C3FileDisplayIconComponent, [{
    type: Component,
    args: [{ selector: "c3-file-display-icon", imports: [CommonModule, MatIconModule], template: '<mat-icon [ngClass]="color()">{{ displayedIcon() }}</mat-icon>\n', styles: ["/* projects/c3-components/src/lib/c3-file-displayer/c3-file-display-icon/c3-file-display-icon.component.scss */\n:host {\n  display: block;\n}\n:host .text-primary {\n  color: var(--primary-color);\n}\n:host .text-secondary {\n  color: var(--secondary-color);\n}\n:host .text-success {\n  color: var(--success-color);\n}\n:host .text-gray {\n  color: var(--gray-color);\n}\n/*# sourceMappingURL=c3-file-display-icon.component.css.map */\n"] }]
  }], null, { fileType: [{ type: Input, args: [{ isSignal: true, alias: "fileType", required: true }] }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(C3FileDisplayIconComponent, { className: "C3FileDisplayIconComponent", filePath: "projects/c3-components/src/lib/c3-file-displayer/c3-file-display-icon/c3-file-display-icon.component.ts", lineNumber: 11 });
})();

// node_modules/@angular/material/fesm2022/menu.mjs
var _c0 = ["mat-menu-item", ""];
var _c1 = [[["mat-icon"], ["", "matMenuItemIcon", ""]], "*"];
var _c2 = ["mat-icon, [matMenuItemIcon]", "*"];
function MatMenuItem_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "svg", 2);
    \u0275\u0275element(1, "polygon", 3);
    \u0275\u0275elementEnd();
  }
}
var _c3 = ["*"];
function MatMenu_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275domElementStart(0, "div", 0);
    \u0275\u0275domListener("click", function MatMenu_ng_template_0_Template_div_click_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.closed.emit("click"));
    })("animationstart", function MatMenu_ng_template_0_Template_div_animationstart_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1._onAnimationStart($event.animationName));
    })("animationend", function MatMenu_ng_template_0_Template_div_animationend_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1._onAnimationDone($event.animationName));
    })("animationcancel", function MatMenu_ng_template_0_Template_div_animationcancel_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1._onAnimationDone($event.animationName));
    });
    \u0275\u0275domElementStart(1, "div", 1);
    \u0275\u0275projection(2);
    \u0275\u0275domElementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r1._classList);
    \u0275\u0275classProp("mat-menu-panel-animations-disabled", ctx_r1._animationsDisabled)("mat-menu-panel-exit-animation", ctx_r1._panelAnimationState === "void")("mat-menu-panel-animating", ctx_r1._isAnimating());
    \u0275\u0275domProperty("id", ctx_r1.panelId);
    \u0275\u0275attribute("aria-label", ctx_r1.ariaLabel || null)("aria-labelledby", ctx_r1.ariaLabelledby || null)("aria-describedby", ctx_r1.ariaDescribedby || null);
  }
}
var MAT_MENU_PANEL = new InjectionToken("MAT_MENU_PANEL");
var MatMenuItem = class _MatMenuItem {
  _elementRef = inject(ElementRef);
  _document = inject(DOCUMENT);
  _focusMonitor = inject(FocusMonitor);
  _parentMenu = inject(MAT_MENU_PANEL, {
    optional: true
  });
  _changeDetectorRef = inject(ChangeDetectorRef);
  /** ARIA role for the menu item. */
  role = "menuitem";
  /** Whether the menu item is disabled. */
  disabled = false;
  /** Whether ripples are disabled on the menu item. */
  disableRipple = false;
  /** Stream that emits when the menu item is hovered. */
  _hovered = new Subject();
  /** Stream that emits when the menu item is focused. */
  _focused = new Subject();
  /** Whether the menu item is highlighted. */
  _highlighted = false;
  /** Whether the menu item acts as a trigger for a sub-menu. */
  _triggersSubmenu = false;
  constructor() {
    inject(_CdkPrivateStyleLoader).load(_StructuralStylesLoader);
    this._parentMenu?.addItem?.(this);
  }
  /** Focuses the menu item. */
  focus(origin, options) {
    if (this._focusMonitor && origin) {
      this._focusMonitor.focusVia(this._getHostElement(), origin, options);
    } else {
      this._getHostElement().focus(options);
    }
    this._focused.next(this);
  }
  ngAfterViewInit() {
    if (this._focusMonitor) {
      this._focusMonitor.monitor(this._elementRef, false);
    }
  }
  ngOnDestroy() {
    if (this._focusMonitor) {
      this._focusMonitor.stopMonitoring(this._elementRef);
    }
    if (this._parentMenu && this._parentMenu.removeItem) {
      this._parentMenu.removeItem(this);
    }
    this._hovered.complete();
    this._focused.complete();
  }
  /** Used to set the `tabindex`. */
  _getTabIndex() {
    return this.disabled ? "-1" : "0";
  }
  /** Returns the host DOM element. */
  _getHostElement() {
    return this._elementRef.nativeElement;
  }
  /** Prevents the default element actions if it is disabled. */
  _checkDisabled(event) {
    if (this.disabled) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  /** Emits to the hover stream. */
  _handleMouseEnter() {
    this._hovered.next(this);
  }
  /** Gets the label to be used when determining whether the option should be focused. */
  getLabel() {
    const clone = this._elementRef.nativeElement.cloneNode(true);
    const icons = clone.querySelectorAll("mat-icon, .material-icons");
    for (let i = 0; i < icons.length; i++) {
      icons[i].remove();
    }
    return clone.textContent?.trim() || "";
  }
  _setHighlighted(isHighlighted) {
    this._highlighted = isHighlighted;
    this._changeDetectorRef.markForCheck();
  }
  _setTriggersSubmenu(triggersSubmenu) {
    this._triggersSubmenu = triggersSubmenu;
    this._changeDetectorRef.markForCheck();
  }
  _hasFocus() {
    return this._document && this._document.activeElement === this._getHostElement();
  }
  static \u0275fac = function MatMenuItem_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatMenuItem)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _MatMenuItem,
    selectors: [["", "mat-menu-item", ""]],
    hostAttrs: [1, "mat-mdc-menu-item", "mat-focus-indicator"],
    hostVars: 8,
    hostBindings: function MatMenuItem_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("click", function MatMenuItem_click_HostBindingHandler($event) {
          return ctx._checkDisabled($event);
        })("mouseenter", function MatMenuItem_mouseenter_HostBindingHandler() {
          return ctx._handleMouseEnter();
        });
      }
      if (rf & 2) {
        \u0275\u0275attribute("role", ctx.role)("tabindex", ctx._getTabIndex())("aria-disabled", ctx.disabled)("disabled", ctx.disabled || null);
        \u0275\u0275classProp("mat-mdc-menu-item-highlighted", ctx._highlighted)("mat-mdc-menu-item-submenu-trigger", ctx._triggersSubmenu);
      }
    },
    inputs: {
      role: "role",
      disabled: [2, "disabled", "disabled", booleanAttribute],
      disableRipple: [2, "disableRipple", "disableRipple", booleanAttribute]
    },
    exportAs: ["matMenuItem"],
    attrs: _c0,
    ngContentSelectors: _c2,
    decls: 5,
    vars: 3,
    consts: [[1, "mat-mdc-menu-item-text"], ["matRipple", "", 1, "mat-mdc-menu-ripple", 3, "matRippleDisabled", "matRippleTrigger"], ["viewBox", "0 0 5 10", "focusable", "false", "aria-hidden", "true", 1, "mat-mdc-menu-submenu-icon"], ["points", "0,0 5,5 0,10"]],
    template: function MatMenuItem_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275projectionDef(_c1);
        \u0275\u0275projection(0);
        \u0275\u0275elementStart(1, "span", 0);
        \u0275\u0275projection(2, 1);
        \u0275\u0275elementEnd();
        \u0275\u0275element(3, "div", 1);
        \u0275\u0275conditionalCreate(4, MatMenuItem_Conditional_4_Template, 2, 0, ":svg:svg", 2);
      }
      if (rf & 2) {
        \u0275\u0275advance(3);
        \u0275\u0275property("matRippleDisabled", ctx.disableRipple || ctx.disabled)("matRippleTrigger", ctx._getHostElement());
        \u0275\u0275advance();
        \u0275\u0275conditional(ctx._triggersSubmenu ? 4 : -1);
      }
    },
    dependencies: [MatRipple],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatMenuItem, [{
    type: Component,
    args: [{
      selector: "[mat-menu-item]",
      exportAs: "matMenuItem",
      host: {
        "[attr.role]": "role",
        "class": "mat-mdc-menu-item mat-focus-indicator",
        "[class.mat-mdc-menu-item-highlighted]": "_highlighted",
        "[class.mat-mdc-menu-item-submenu-trigger]": "_triggersSubmenu",
        "[attr.tabindex]": "_getTabIndex()",
        "[attr.aria-disabled]": "disabled",
        "[attr.disabled]": "disabled || null",
        "(click)": "_checkDisabled($event)",
        "(mouseenter)": "_handleMouseEnter()"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      imports: [MatRipple],
      template: '<ng-content select="mat-icon, [matMenuItemIcon]"></ng-content>\n<span class="mat-mdc-menu-item-text"><ng-content></ng-content></span>\n<div class="mat-mdc-menu-ripple" matRipple\n     [matRippleDisabled]="disableRipple || disabled"\n     [matRippleTrigger]="_getHostElement()">\n</div>\n\n@if (_triggersSubmenu) {\n     <svg\n       class="mat-mdc-menu-submenu-icon"\n       viewBox="0 0 5 10"\n       focusable="false"\n       aria-hidden="true"><polygon points="0,0 5,5 0,10"/></svg>\n}\n'
    }]
  }], () => [], {
    role: [{
      type: Input
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    disableRipple: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }]
  });
})();
function throwMatMenuInvalidPositionX() {
  throw Error(`xPosition value must be either 'before' or after'.
      Example: <mat-menu xPosition="before" #menu="matMenu"></mat-menu>`);
}
function throwMatMenuInvalidPositionY() {
  throw Error(`yPosition value must be either 'above' or below'.
      Example: <mat-menu yPosition="above" #menu="matMenu"></mat-menu>`);
}
function throwMatMenuRecursiveError() {
  throw Error(`matMenuTriggerFor: menu cannot contain its own trigger. Assign a menu that is not a parent of the trigger or move the trigger outside of the menu.`);
}
var MAT_MENU_CONTENT = new InjectionToken("MatMenuContent");
var MatMenuContent = class _MatMenuContent {
  _template = inject(TemplateRef);
  _appRef = inject(ApplicationRef);
  _injector = inject(Injector);
  _viewContainerRef = inject(ViewContainerRef);
  _document = inject(DOCUMENT);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _portal;
  _outlet;
  /** Emits when the menu content has been attached. */
  _attached = new Subject();
  constructor() {
  }
  /**
   * Attaches the content with a particular context.
   * @docs-private
   */
  attach(context = {}) {
    if (!this._portal) {
      this._portal = new TemplatePortal(this._template, this._viewContainerRef);
    }
    this.detach();
    if (!this._outlet) {
      this._outlet = new DomPortalOutlet(this._document.createElement("div"), this._appRef, this._injector);
    }
    const element = this._template.elementRef.nativeElement;
    element.parentNode.insertBefore(this._outlet.outletElement, element);
    this._changeDetectorRef.markForCheck();
    this._portal.attach(this._outlet, context);
    this._attached.next();
  }
  /**
   * Detaches the content.
   * @docs-private
   */
  detach() {
    if (this._portal?.isAttached) {
      this._portal.detach();
    }
  }
  ngOnDestroy() {
    this.detach();
    this._outlet?.dispose();
  }
  static \u0275fac = function MatMenuContent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatMenuContent)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _MatMenuContent,
    selectors: [["ng-template", "matMenuContent", ""]],
    features: [\u0275\u0275ProvidersFeature([{
      provide: MAT_MENU_CONTENT,
      useExisting: _MatMenuContent
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatMenuContent, [{
    type: Directive,
    args: [{
      selector: "ng-template[matMenuContent]",
      providers: [{
        provide: MAT_MENU_CONTENT,
        useExisting: MatMenuContent
      }]
    }]
  }], () => [], null);
})();
var MAT_MENU_DEFAULT_OPTIONS = new InjectionToken("mat-menu-default-options", {
  providedIn: "root",
  factory: MAT_MENU_DEFAULT_OPTIONS_FACTORY
});
function MAT_MENU_DEFAULT_OPTIONS_FACTORY() {
  return {
    overlapTrigger: false,
    xPosition: "after",
    yPosition: "below",
    backdropClass: "cdk-overlay-transparent-backdrop"
  };
}
var ENTER_ANIMATION = "_mat-menu-enter";
var EXIT_ANIMATION = "_mat-menu-exit";
var MatMenu = class _MatMenu {
  _elementRef = inject(ElementRef);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _injector = inject(Injector);
  _keyManager;
  _xPosition;
  _yPosition;
  _firstItemFocusRef;
  _exitFallbackTimeout;
  /** Whether animations are currently disabled. */
  _animationsDisabled = _animationsDisabled();
  /** All items inside the menu. Includes items nested inside another menu. */
  _allItems;
  /** Only the direct descendant menu items. */
  _directDescendantItems = new QueryList();
  /** Classes to be applied to the menu panel. */
  _classList = {};
  /** Current state of the panel animation. */
  _panelAnimationState = "void";
  /** Emits whenever an animation on the menu completes. */
  _animationDone = new Subject();
  /** Whether the menu is animating. */
  _isAnimating = signal(false, ...ngDevMode ? [{
    debugName: "_isAnimating"
  }] : []);
  /** Parent menu of the current menu panel. */
  parentMenu;
  /** Layout direction of the menu. */
  direction;
  /** Class or list of classes to be added to the overlay panel. */
  overlayPanelClass;
  /** Class to be added to the backdrop element. */
  backdropClass;
  /** aria-label for the menu panel. */
  ariaLabel;
  /** aria-labelledby for the menu panel. */
  ariaLabelledby;
  /** aria-describedby for the menu panel. */
  ariaDescribedby;
  /** Position of the menu in the X axis. */
  get xPosition() {
    return this._xPosition;
  }
  set xPosition(value) {
    if (value !== "before" && value !== "after" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throwMatMenuInvalidPositionX();
    }
    this._xPosition = value;
    this.setPositionClasses();
  }
  /** Position of the menu in the Y axis. */
  get yPosition() {
    return this._yPosition;
  }
  set yPosition(value) {
    if (value !== "above" && value !== "below" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throwMatMenuInvalidPositionY();
    }
    this._yPosition = value;
    this.setPositionClasses();
  }
  /** @docs-private */
  templateRef;
  /**
   * List of the items inside of a menu.
   * @deprecated
   * @breaking-change 8.0.0
   */
  items;
  /**
   * Menu content that will be rendered lazily.
   * @docs-private
   */
  lazyContent;
  /** Whether the menu should overlap its trigger. */
  overlapTrigger;
  /** Whether the menu has a backdrop. */
  hasBackdrop;
  /**
   * This method takes classes set on the host mat-menu element and applies them on the
   * menu template that displays in the overlay container.  Otherwise, it's difficult
   * to style the containing menu from outside the component.
   * @param classes list of class names
   */
  set panelClass(classes) {
    const previousPanelClass = this._previousPanelClass;
    const newClassList = __spreadValues({}, this._classList);
    if (previousPanelClass && previousPanelClass.length) {
      previousPanelClass.split(" ").forEach((className) => {
        newClassList[className] = false;
      });
    }
    this._previousPanelClass = classes;
    if (classes && classes.length) {
      classes.split(" ").forEach((className) => {
        newClassList[className] = true;
      });
      this._elementRef.nativeElement.className = "";
    }
    this._classList = newClassList;
  }
  _previousPanelClass;
  /**
   * This method takes classes set on the host mat-menu element and applies them on the
   * menu template that displays in the overlay container.  Otherwise, it's difficult
   * to style the containing menu from outside the component.
   * @deprecated Use `panelClass` instead.
   * @breaking-change 8.0.0
   */
  get classList() {
    return this.panelClass;
  }
  set classList(classes) {
    this.panelClass = classes;
  }
  /** Event emitted when the menu is closed. */
  closed = new EventEmitter();
  /**
   * Event emitted when the menu is closed.
   * @deprecated Switch to `closed` instead
   * @breaking-change 8.0.0
   */
  close = this.closed;
  panelId = inject(_IdGenerator).getId("mat-menu-panel-");
  constructor() {
    const defaultOptions = inject(MAT_MENU_DEFAULT_OPTIONS);
    this.overlayPanelClass = defaultOptions.overlayPanelClass || "";
    this._xPosition = defaultOptions.xPosition;
    this._yPosition = defaultOptions.yPosition;
    this.backdropClass = defaultOptions.backdropClass;
    this.overlapTrigger = defaultOptions.overlapTrigger;
    this.hasBackdrop = defaultOptions.hasBackdrop;
  }
  ngOnInit() {
    this.setPositionClasses();
  }
  ngAfterContentInit() {
    this._updateDirectDescendants();
    this._keyManager = new FocusKeyManager(this._directDescendantItems).withWrap().withTypeAhead().withHomeAndEnd();
    this._keyManager.tabOut.subscribe(() => this.closed.emit("tab"));
    this._directDescendantItems.changes.pipe(startWith(this._directDescendantItems), switchMap((items) => merge(...items.map((item) => item._focused)))).subscribe((focusedItem) => this._keyManager.updateActiveItem(focusedItem));
    this._directDescendantItems.changes.subscribe((itemsList) => {
      const manager = this._keyManager;
      if (this._panelAnimationState === "enter" && manager.activeItem?._hasFocus()) {
        const items = itemsList.toArray();
        const index = Math.max(0, Math.min(items.length - 1, manager.activeItemIndex || 0));
        if (items[index] && !items[index].disabled) {
          manager.setActiveItem(index);
        } else {
          manager.setNextItemActive();
        }
      }
    });
  }
  ngOnDestroy() {
    this._keyManager?.destroy();
    this._directDescendantItems.destroy();
    this.closed.complete();
    this._firstItemFocusRef?.destroy();
    clearTimeout(this._exitFallbackTimeout);
  }
  /** Stream that emits whenever the hovered menu item changes. */
  _hovered() {
    const itemChanges = this._directDescendantItems.changes;
    return itemChanges.pipe(startWith(this._directDescendantItems), switchMap((items) => merge(...items.map((item) => item._hovered))));
  }
  /*
   * Registers a menu item with the menu.
   * @docs-private
   * @deprecated No longer being used. To be removed.
   * @breaking-change 9.0.0
   */
  addItem(_item) {
  }
  /**
   * Removes an item from the menu.
   * @docs-private
   * @deprecated No longer being used. To be removed.
   * @breaking-change 9.0.0
   */
  removeItem(_item) {
  }
  /** Handle a keyboard event from the menu, delegating to the appropriate action. */
  _handleKeydown(event) {
    const keyCode = event.keyCode;
    const manager = this._keyManager;
    switch (keyCode) {
      case ESCAPE:
        if (!hasModifierKey(event)) {
          event.preventDefault();
          this.closed.emit("keydown");
        }
        break;
      case LEFT_ARROW:
        if (this.parentMenu && this.direction === "ltr") {
          this.closed.emit("keydown");
        }
        break;
      case RIGHT_ARROW:
        if (this.parentMenu && this.direction === "rtl") {
          this.closed.emit("keydown");
        }
        break;
      default:
        if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {
          manager.setFocusOrigin("keyboard");
        }
        manager.onKeydown(event);
        return;
    }
  }
  /**
   * Focus the first item in the menu.
   * @param origin Action from which the focus originated. Used to set the correct styling.
   */
  focusFirstItem(origin = "program") {
    this._firstItemFocusRef?.destroy();
    this._firstItemFocusRef = afterNextRender(() => {
      const menuPanel = this._resolvePanel();
      if (!menuPanel || !menuPanel.contains(document.activeElement)) {
        const manager = this._keyManager;
        manager.setFocusOrigin(origin).setFirstItemActive();
        if (!manager.activeItem && menuPanel) {
          menuPanel.focus();
        }
      }
    }, {
      injector: this._injector
    });
  }
  /**
   * Resets the active item in the menu. This is used when the menu is opened, allowing
   * the user to start from the first option when pressing the down arrow.
   */
  resetActiveItem() {
    this._keyManager.setActiveItem(-1);
  }
  /**
   * @deprecated No longer used and will be removed.
   * @breaking-change 21.0.0
   */
  setElevation(_depth) {
  }
  /**
   * Adds classes to the menu panel based on its position. Can be used by
   * consumers to add specific styling based on the position.
   * @param posX Position of the menu along the x axis.
   * @param posY Position of the menu along the y axis.
   * @docs-private
   */
  setPositionClasses(posX = this.xPosition, posY = this.yPosition) {
    this._classList = __spreadProps(__spreadValues({}, this._classList), {
      ["mat-menu-before"]: posX === "before",
      ["mat-menu-after"]: posX === "after",
      ["mat-menu-above"]: posY === "above",
      ["mat-menu-below"]: posY === "below"
    });
    this._changeDetectorRef.markForCheck();
  }
  /** Callback that is invoked when the panel animation completes. */
  _onAnimationDone(state) {
    const isExit = state === EXIT_ANIMATION;
    if (isExit || state === ENTER_ANIMATION) {
      if (isExit) {
        clearTimeout(this._exitFallbackTimeout);
        this._exitFallbackTimeout = void 0;
      }
      this._animationDone.next(isExit ? "void" : "enter");
      this._isAnimating.set(false);
    }
  }
  _onAnimationStart(state) {
    if (state === ENTER_ANIMATION || state === EXIT_ANIMATION) {
      this._isAnimating.set(true);
    }
  }
  _setIsOpen(isOpen) {
    this._panelAnimationState = isOpen ? "enter" : "void";
    if (isOpen) {
      if (this._keyManager.activeItemIndex === 0) {
        const menuPanel = this._resolvePanel();
        if (menuPanel) {
          menuPanel.scrollTop = 0;
        }
      }
    } else if (!this._animationsDisabled) {
      this._exitFallbackTimeout = setTimeout(() => this._onAnimationDone(EXIT_ANIMATION), 200);
    }
    if (this._animationsDisabled) {
      setTimeout(() => {
        this._onAnimationDone(isOpen ? ENTER_ANIMATION : EXIT_ANIMATION);
      });
    }
    this._changeDetectorRef.markForCheck();
  }
  /**
   * Sets up a stream that will keep track of any newly-added menu items and will update the list
   * of direct descendants. We collect the descendants this way, because `_allItems` can include
   * items that are part of child menus, and using a custom way of registering items is unreliable
   * when it comes to maintaining the item order.
   */
  _updateDirectDescendants() {
    this._allItems.changes.pipe(startWith(this._allItems)).subscribe((items) => {
      this._directDescendantItems.reset(items.filter((item) => item._parentMenu === this));
      this._directDescendantItems.notifyOnChanges();
    });
  }
  /** Gets the menu panel DOM node. */
  _resolvePanel() {
    let menuPanel = null;
    if (this._directDescendantItems.length) {
      menuPanel = this._directDescendantItems.first._getHostElement().closest('[role="menu"]');
    }
    return menuPanel;
  }
  static \u0275fac = function MatMenu_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatMenu)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _MatMenu,
    selectors: [["mat-menu"]],
    contentQueries: function MatMenu_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuery(dirIndex, MAT_MENU_CONTENT, 5);
        \u0275\u0275contentQuery(dirIndex, MatMenuItem, 5);
        \u0275\u0275contentQuery(dirIndex, MatMenuItem, 4);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.lazyContent = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx._allItems = _t);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.items = _t);
      }
    },
    viewQuery: function MatMenu_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(TemplateRef, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.templateRef = _t.first);
      }
    },
    hostVars: 3,
    hostBindings: function MatMenu_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275attribute("aria-label", null)("aria-labelledby", null)("aria-describedby", null);
      }
    },
    inputs: {
      backdropClass: "backdropClass",
      ariaLabel: [0, "aria-label", "ariaLabel"],
      ariaLabelledby: [0, "aria-labelledby", "ariaLabelledby"],
      ariaDescribedby: [0, "aria-describedby", "ariaDescribedby"],
      xPosition: "xPosition",
      yPosition: "yPosition",
      overlapTrigger: [2, "overlapTrigger", "overlapTrigger", booleanAttribute],
      hasBackdrop: [2, "hasBackdrop", "hasBackdrop", (value) => value == null ? null : booleanAttribute(value)],
      panelClass: [0, "class", "panelClass"],
      classList: "classList"
    },
    outputs: {
      closed: "closed",
      close: "close"
    },
    exportAs: ["matMenu"],
    features: [\u0275\u0275ProvidersFeature([{
      provide: MAT_MENU_PANEL,
      useExisting: _MatMenu
    }])],
    ngContentSelectors: _c3,
    decls: 1,
    vars: 0,
    consts: [["tabindex", "-1", "role", "menu", 1, "mat-mdc-menu-panel", 3, "click", "animationstart", "animationend", "animationcancel", "id"], [1, "mat-mdc-menu-content"]],
    template: function MatMenu_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275projectionDef();
        \u0275\u0275domTemplate(0, MatMenu_ng_template_0_Template, 3, 12, "ng-template");
      }
    },
    styles: ['mat-menu{display:none}.mat-mdc-menu-content{margin:0;padding:8px 0;outline:0}.mat-mdc-menu-content,.mat-mdc-menu-content .mat-mdc-menu-item .mat-mdc-menu-item-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;flex:1;white-space:normal;font-family:var(--mat-menu-item-label-text-font, var(--mat-sys-label-large-font));line-height:var(--mat-menu-item-label-text-line-height, var(--mat-sys-label-large-line-height));font-size:var(--mat-menu-item-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mat-menu-item-label-text-tracking, var(--mat-sys-label-large-tracking));font-weight:var(--mat-menu-item-label-text-weight, var(--mat-sys-label-large-weight))}@keyframes _mat-menu-enter{from{opacity:0;transform:scale(0.8)}to{opacity:1;transform:none}}@keyframes _mat-menu-exit{from{opacity:1}to{opacity:0}}.mat-mdc-menu-panel{min-width:112px;max-width:280px;overflow:auto;box-sizing:border-box;outline:0;animation:_mat-menu-enter 120ms cubic-bezier(0, 0, 0.2, 1);border-radius:var(--mat-menu-container-shape, var(--mat-sys-corner-extra-small));background-color:var(--mat-menu-container-color, var(--mat-sys-surface-container));box-shadow:var(--mat-menu-container-elevation-shadow, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12));will-change:transform,opacity}.mat-mdc-menu-panel.mat-menu-panel-exit-animation{animation:_mat-menu-exit 100ms 25ms linear forwards}.mat-mdc-menu-panel.mat-menu-panel-animations-disabled{animation:none}.mat-mdc-menu-panel.mat-menu-panel-animating{pointer-events:none}.mat-mdc-menu-panel.mat-menu-panel-animating:has(.mat-mdc-menu-content:empty){display:none}@media(forced-colors: active){.mat-mdc-menu-panel{outline:solid 1px}}.mat-mdc-menu-panel .mat-divider{color:var(--mat-menu-divider-color, var(--mat-sys-surface-variant));margin-bottom:var(--mat-menu-divider-bottom-spacing, 8px);margin-top:var(--mat-menu-divider-top-spacing, 8px)}.mat-mdc-menu-item{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;cursor:pointer;width:100%;text-align:left;box-sizing:border-box;color:inherit;font-size:inherit;background:none;text-decoration:none;margin:0;min-height:48px;padding-left:var(--mat-menu-item-leading-spacing, 12px);padding-right:var(--mat-menu-item-trailing-spacing, 12px);-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-menu-item::-moz-focus-inner{border:0}[dir=rtl] .mat-mdc-menu-item{padding-left:var(--mat-menu-item-trailing-spacing, 12px);padding-right:var(--mat-menu-item-leading-spacing, 12px)}.mat-mdc-menu-item:has(.material-icons,mat-icon,[matButtonIcon]){padding-left:var(--mat-menu-item-with-icon-leading-spacing, 12px);padding-right:var(--mat-menu-item-with-icon-trailing-spacing, 12px)}[dir=rtl] .mat-mdc-menu-item:has(.material-icons,mat-icon,[matButtonIcon]){padding-left:var(--mat-menu-item-with-icon-trailing-spacing, 12px);padding-right:var(--mat-menu-item-with-icon-leading-spacing, 12px)}.mat-mdc-menu-item,.mat-mdc-menu-item:visited,.mat-mdc-menu-item:link{color:var(--mat-menu-item-label-text-color, var(--mat-sys-on-surface))}.mat-mdc-menu-item .mat-icon-no-color,.mat-mdc-menu-item .mat-mdc-menu-submenu-icon{color:var(--mat-menu-item-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-menu-item[disabled]{cursor:default;opacity:.38}.mat-mdc-menu-item[disabled]::after{display:block;position:absolute;content:"";top:0;left:0;bottom:0;right:0}.mat-mdc-menu-item:focus{outline:0}.mat-mdc-menu-item .mat-icon{flex-shrink:0;margin-right:var(--mat-menu-item-spacing, 12px);height:var(--mat-menu-item-icon-size, 24px);width:var(--mat-menu-item-icon-size, 24px)}[dir=rtl] .mat-mdc-menu-item{text-align:right}[dir=rtl] .mat-mdc-menu-item .mat-icon{margin-right:0;margin-left:var(--mat-menu-item-spacing, 12px)}.mat-mdc-menu-item:not([disabled]):hover{background-color:var(--mat-menu-item-hover-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-hover-state-layer-opacity) * 100%), transparent))}.mat-mdc-menu-item:not([disabled]).cdk-program-focused,.mat-mdc-menu-item:not([disabled]).cdk-keyboard-focused,.mat-mdc-menu-item:not([disabled]).mat-mdc-menu-item-highlighted{background-color:var(--mat-menu-item-focus-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-focus-state-layer-opacity) * 100%), transparent))}@media(forced-colors: active){.mat-mdc-menu-item{margin-top:1px}}.mat-mdc-menu-submenu-icon{width:var(--mat-menu-item-icon-size, 24px);height:10px;fill:currentColor;padding-left:var(--mat-menu-item-spacing, 12px)}[dir=rtl] .mat-mdc-menu-submenu-icon{padding-right:var(--mat-menu-item-spacing, 12px);padding-left:0}[dir=rtl] .mat-mdc-menu-submenu-icon polygon{transform:scaleX(-1);transform-origin:center}@media(forced-colors: active){.mat-mdc-menu-submenu-icon{fill:CanvasText}}.mat-mdc-menu-item .mat-mdc-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\n'],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatMenu, [{
    type: Component,
    args: [{
      selector: "mat-menu",
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      exportAs: "matMenu",
      host: {
        "[attr.aria-label]": "null",
        "[attr.aria-labelledby]": "null",
        "[attr.aria-describedby]": "null"
      },
      providers: [{
        provide: MAT_MENU_PANEL,
        useExisting: MatMenu
      }],
      template: `<ng-template>
  <div
    class="mat-mdc-menu-panel"
    [id]="panelId"
    [class]="_classList"
    [class.mat-menu-panel-animations-disabled]="_animationsDisabled"
    [class.mat-menu-panel-exit-animation]="_panelAnimationState === 'void'"
    [class.mat-menu-panel-animating]="_isAnimating()"
    (click)="closed.emit('click')"
    tabindex="-1"
    role="menu"
    (animationstart)="_onAnimationStart($event.animationName)"
    (animationend)="_onAnimationDone($event.animationName)"
    (animationcancel)="_onAnimationDone($event.animationName)"
    [attr.aria-label]="ariaLabel || null"
    [attr.aria-labelledby]="ariaLabelledby || null"
    [attr.aria-describedby]="ariaDescribedby || null">
    <div class="mat-mdc-menu-content">
      <ng-content></ng-content>
    </div>
  </div>
</ng-template>
`,
      styles: ['mat-menu{display:none}.mat-mdc-menu-content{margin:0;padding:8px 0;outline:0}.mat-mdc-menu-content,.mat-mdc-menu-content .mat-mdc-menu-item .mat-mdc-menu-item-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;flex:1;white-space:normal;font-family:var(--mat-menu-item-label-text-font, var(--mat-sys-label-large-font));line-height:var(--mat-menu-item-label-text-line-height, var(--mat-sys-label-large-line-height));font-size:var(--mat-menu-item-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mat-menu-item-label-text-tracking, var(--mat-sys-label-large-tracking));font-weight:var(--mat-menu-item-label-text-weight, var(--mat-sys-label-large-weight))}@keyframes _mat-menu-enter{from{opacity:0;transform:scale(0.8)}to{opacity:1;transform:none}}@keyframes _mat-menu-exit{from{opacity:1}to{opacity:0}}.mat-mdc-menu-panel{min-width:112px;max-width:280px;overflow:auto;box-sizing:border-box;outline:0;animation:_mat-menu-enter 120ms cubic-bezier(0, 0, 0.2, 1);border-radius:var(--mat-menu-container-shape, var(--mat-sys-corner-extra-small));background-color:var(--mat-menu-container-color, var(--mat-sys-surface-container));box-shadow:var(--mat-menu-container-elevation-shadow, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12));will-change:transform,opacity}.mat-mdc-menu-panel.mat-menu-panel-exit-animation{animation:_mat-menu-exit 100ms 25ms linear forwards}.mat-mdc-menu-panel.mat-menu-panel-animations-disabled{animation:none}.mat-mdc-menu-panel.mat-menu-panel-animating{pointer-events:none}.mat-mdc-menu-panel.mat-menu-panel-animating:has(.mat-mdc-menu-content:empty){display:none}@media(forced-colors: active){.mat-mdc-menu-panel{outline:solid 1px}}.mat-mdc-menu-panel .mat-divider{color:var(--mat-menu-divider-color, var(--mat-sys-surface-variant));margin-bottom:var(--mat-menu-divider-bottom-spacing, 8px);margin-top:var(--mat-menu-divider-top-spacing, 8px)}.mat-mdc-menu-item{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;cursor:pointer;width:100%;text-align:left;box-sizing:border-box;color:inherit;font-size:inherit;background:none;text-decoration:none;margin:0;min-height:48px;padding-left:var(--mat-menu-item-leading-spacing, 12px);padding-right:var(--mat-menu-item-trailing-spacing, 12px);-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-menu-item::-moz-focus-inner{border:0}[dir=rtl] .mat-mdc-menu-item{padding-left:var(--mat-menu-item-trailing-spacing, 12px);padding-right:var(--mat-menu-item-leading-spacing, 12px)}.mat-mdc-menu-item:has(.material-icons,mat-icon,[matButtonIcon]){padding-left:var(--mat-menu-item-with-icon-leading-spacing, 12px);padding-right:var(--mat-menu-item-with-icon-trailing-spacing, 12px)}[dir=rtl] .mat-mdc-menu-item:has(.material-icons,mat-icon,[matButtonIcon]){padding-left:var(--mat-menu-item-with-icon-trailing-spacing, 12px);padding-right:var(--mat-menu-item-with-icon-leading-spacing, 12px)}.mat-mdc-menu-item,.mat-mdc-menu-item:visited,.mat-mdc-menu-item:link{color:var(--mat-menu-item-label-text-color, var(--mat-sys-on-surface))}.mat-mdc-menu-item .mat-icon-no-color,.mat-mdc-menu-item .mat-mdc-menu-submenu-icon{color:var(--mat-menu-item-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-menu-item[disabled]{cursor:default;opacity:.38}.mat-mdc-menu-item[disabled]::after{display:block;position:absolute;content:"";top:0;left:0;bottom:0;right:0}.mat-mdc-menu-item:focus{outline:0}.mat-mdc-menu-item .mat-icon{flex-shrink:0;margin-right:var(--mat-menu-item-spacing, 12px);height:var(--mat-menu-item-icon-size, 24px);width:var(--mat-menu-item-icon-size, 24px)}[dir=rtl] .mat-mdc-menu-item{text-align:right}[dir=rtl] .mat-mdc-menu-item .mat-icon{margin-right:0;margin-left:var(--mat-menu-item-spacing, 12px)}.mat-mdc-menu-item:not([disabled]):hover{background-color:var(--mat-menu-item-hover-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-hover-state-layer-opacity) * 100%), transparent))}.mat-mdc-menu-item:not([disabled]).cdk-program-focused,.mat-mdc-menu-item:not([disabled]).cdk-keyboard-focused,.mat-mdc-menu-item:not([disabled]).mat-mdc-menu-item-highlighted{background-color:var(--mat-menu-item-focus-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-focus-state-layer-opacity) * 100%), transparent))}@media(forced-colors: active){.mat-mdc-menu-item{margin-top:1px}}.mat-mdc-menu-submenu-icon{width:var(--mat-menu-item-icon-size, 24px);height:10px;fill:currentColor;padding-left:var(--mat-menu-item-spacing, 12px)}[dir=rtl] .mat-mdc-menu-submenu-icon{padding-right:var(--mat-menu-item-spacing, 12px);padding-left:0}[dir=rtl] .mat-mdc-menu-submenu-icon polygon{transform:scaleX(-1);transform-origin:center}@media(forced-colors: active){.mat-mdc-menu-submenu-icon{fill:CanvasText}}.mat-mdc-menu-item .mat-mdc-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\n']
    }]
  }], () => [], {
    _allItems: [{
      type: ContentChildren,
      args: [MatMenuItem, {
        descendants: true
      }]
    }],
    backdropClass: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input,
      args: ["aria-label"]
    }],
    ariaLabelledby: [{
      type: Input,
      args: ["aria-labelledby"]
    }],
    ariaDescribedby: [{
      type: Input,
      args: ["aria-describedby"]
    }],
    xPosition: [{
      type: Input
    }],
    yPosition: [{
      type: Input
    }],
    templateRef: [{
      type: ViewChild,
      args: [TemplateRef]
    }],
    items: [{
      type: ContentChildren,
      args: [MatMenuItem, {
        descendants: false
      }]
    }],
    lazyContent: [{
      type: ContentChild,
      args: [MAT_MENU_CONTENT]
    }],
    overlapTrigger: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    hasBackdrop: [{
      type: Input,
      args: [{
        transform: (value) => value == null ? null : booleanAttribute(value)
      }]
    }],
    panelClass: [{
      type: Input,
      args: ["class"]
    }],
    classList: [{
      type: Input
    }],
    closed: [{
      type: Output
    }],
    close: [{
      type: Output
    }]
  });
})();
var MAT_MENU_SCROLL_STRATEGY = new InjectionToken("mat-menu-scroll-strategy", {
  providedIn: "root",
  factory: () => {
    const injector = inject(Injector);
    return () => createRepositionScrollStrategy(injector);
  }
});
function MAT_MENU_SCROLL_STRATEGY_FACTORY(_overlay) {
  const injector = inject(Injector);
  return () => createRepositionScrollStrategy(injector);
}
var MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER = {
  provide: MAT_MENU_SCROLL_STRATEGY,
  deps: [],
  useFactory: MAT_MENU_SCROLL_STRATEGY_FACTORY
};
var PANELS_TO_TRIGGERS = /* @__PURE__ */ new WeakMap();
var MatMenuTriggerBase = class _MatMenuTriggerBase {
  _canHaveBackdrop;
  _element = inject(ElementRef);
  _viewContainerRef = inject(ViewContainerRef);
  _menuItemInstance = inject(MatMenuItem, {
    optional: true,
    self: true
  });
  _dir = inject(Directionality, {
    optional: true
  });
  _focusMonitor = inject(FocusMonitor);
  _ngZone = inject(NgZone);
  _injector = inject(Injector);
  _scrollStrategy = inject(MAT_MENU_SCROLL_STRATEGY);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _animationsDisabled = _animationsDisabled();
  _portal;
  _overlayRef = null;
  _menuOpen = false;
  _closingActionsSubscription = Subscription.EMPTY;
  _menuCloseSubscription = Subscription.EMPTY;
  _pendingRemoval;
  /**
   * We're specifically looking for a `MatMenu` here since the generic `MatMenuPanel`
   * interface lacks some functionality around nested menus and animations.
   */
  _parentMaterialMenu;
  /**
   * Cached value of the padding of the parent menu panel.
   * Used to offset sub-menus to compensate for the padding.
   */
  _parentInnerPadding;
  // Tracking input type is necessary so it's possible to only auto-focus
  // the first item of the list when the menu is opened via the keyboard
  _openedBy = void 0;
  /** Menu currently assigned to the trigger. */
  get _menu() {
    return this._menuInternal;
  }
  set _menu(menu) {
    if (menu === this._menuInternal) {
      return;
    }
    this._menuInternal = menu;
    this._menuCloseSubscription.unsubscribe();
    if (menu) {
      if (menu === this._parentMaterialMenu && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throwMatMenuRecursiveError();
      }
      this._menuCloseSubscription = menu.close.subscribe((reason) => {
        this._destroyMenu(reason);
        if ((reason === "click" || reason === "tab") && this._parentMaterialMenu) {
          this._parentMaterialMenu.closed.emit(reason);
        }
      });
    }
    this._menuItemInstance?._setTriggersSubmenu(this._triggersSubmenu());
  }
  _menuInternal;
  constructor(_canHaveBackdrop) {
    this._canHaveBackdrop = _canHaveBackdrop;
    const parentMenu = inject(MAT_MENU_PANEL, {
      optional: true
    });
    this._parentMaterialMenu = parentMenu instanceof MatMenu ? parentMenu : void 0;
  }
  ngOnDestroy() {
    if (this._menu && this._ownsMenu(this._menu)) {
      PANELS_TO_TRIGGERS.delete(this._menu);
    }
    this._pendingRemoval?.unsubscribe();
    this._menuCloseSubscription.unsubscribe();
    this._closingActionsSubscription.unsubscribe();
    if (this._overlayRef) {
      this._overlayRef.dispose();
      this._overlayRef = null;
    }
  }
  /** Whether the menu is open. */
  get menuOpen() {
    return this._menuOpen;
  }
  /** The text direction of the containing app. */
  get dir() {
    return this._dir && this._dir.value === "rtl" ? "rtl" : "ltr";
  }
  /** Whether the menu triggers a sub-menu or a top-level one. */
  _triggersSubmenu() {
    return !!(this._menuItemInstance && this._parentMaterialMenu && this._menu);
  }
  _closeMenu() {
    this._menu?.close.emit();
  }
  /** Internal method to open menu providing option to auto focus on first item. */
  _openMenu(autoFocus) {
    const menu = this._menu;
    if (this._menuOpen || !menu) {
      return;
    }
    this._pendingRemoval?.unsubscribe();
    const previousTrigger = PANELS_TO_TRIGGERS.get(menu);
    PANELS_TO_TRIGGERS.set(menu, this);
    if (previousTrigger && previousTrigger !== this) {
      previousTrigger._closeMenu();
    }
    const overlayRef = this._createOverlay(menu);
    const overlayConfig = overlayRef.getConfig();
    const positionStrategy = overlayConfig.positionStrategy;
    this._setPosition(menu, positionStrategy);
    if (this._canHaveBackdrop) {
      overlayConfig.hasBackdrop = menu.hasBackdrop == null ? !this._triggersSubmenu() : menu.hasBackdrop;
    } else {
      overlayConfig.hasBackdrop = false;
    }
    if (!overlayRef.hasAttached()) {
      overlayRef.attach(this._getPortal(menu));
      menu.lazyContent?.attach(this.menuData);
    }
    this._closingActionsSubscription = this._menuClosingActions().subscribe(() => this._closeMenu());
    menu.parentMenu = this._triggersSubmenu() ? this._parentMaterialMenu : void 0;
    menu.direction = this.dir;
    if (autoFocus) {
      menu.focusFirstItem(this._openedBy || "program");
    }
    this._setIsMenuOpen(true);
    if (menu instanceof MatMenu) {
      menu._setIsOpen(true);
      menu._directDescendantItems.changes.pipe(takeUntil(menu.close)).subscribe(() => {
        positionStrategy.withLockedPosition(false).reapplyLastPosition();
        positionStrategy.withLockedPosition(true);
      });
    }
  }
  /**
   * Focuses the menu trigger.
   * @param origin Source of the menu trigger's focus.
   */
  focus(origin, options) {
    if (this._focusMonitor && origin) {
      this._focusMonitor.focusVia(this._element, origin, options);
    } else {
      this._element.nativeElement.focus(options);
    }
  }
  /** Closes the menu and does the necessary cleanup. */
  _destroyMenu(reason) {
    const overlayRef = this._overlayRef;
    const menu = this._menu;
    if (!overlayRef || !this.menuOpen) {
      return;
    }
    this._closingActionsSubscription.unsubscribe();
    this._pendingRemoval?.unsubscribe();
    if (menu instanceof MatMenu && this._ownsMenu(menu)) {
      this._pendingRemoval = menu._animationDone.pipe(take(1)).subscribe(() => {
        overlayRef.detach();
        if (!PANELS_TO_TRIGGERS.has(menu)) {
          menu.lazyContent?.detach();
        }
      });
      menu._setIsOpen(false);
    } else {
      overlayRef.detach();
      menu?.lazyContent?.detach();
    }
    if (menu && this._ownsMenu(menu)) {
      PANELS_TO_TRIGGERS.delete(menu);
    }
    if (this.restoreFocus && (reason === "keydown" || !this._openedBy || !this._triggersSubmenu())) {
      this.focus(this._openedBy);
    }
    this._openedBy = void 0;
    this._setIsMenuOpen(false);
  }
  // set state rather than toggle to support triggers sharing a menu
  _setIsMenuOpen(isOpen) {
    if (isOpen !== this._menuOpen) {
      this._menuOpen = isOpen;
      this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();
      if (this._triggersSubmenu()) {
        this._menuItemInstance._setHighlighted(isOpen);
      }
      this._changeDetectorRef.markForCheck();
    }
  }
  /**
   * This method creates the overlay from the provided menu's template and saves its
   * OverlayRef so that it can be attached to the DOM when openMenu is called.
   */
  _createOverlay(menu) {
    if (!this._overlayRef) {
      const config = this._getOverlayConfig(menu);
      this._subscribeToPositions(menu, config.positionStrategy);
      this._overlayRef = createOverlayRef(this._injector, config);
      this._overlayRef.keydownEvents().subscribe((event) => {
        if (this._menu instanceof MatMenu) {
          this._menu._handleKeydown(event);
        }
      });
    }
    return this._overlayRef;
  }
  /**
   * This method builds the configuration object needed to create the overlay, the OverlayState.
   * @returns OverlayConfig
   */
  _getOverlayConfig(menu) {
    return new OverlayConfig({
      positionStrategy: createFlexibleConnectedPositionStrategy(this._injector, this._getOverlayOrigin()).withLockedPosition().withGrowAfterOpen().withTransformOriginOn(".mat-menu-panel, .mat-mdc-menu-panel"),
      backdropClass: menu.backdropClass || "cdk-overlay-transparent-backdrop",
      panelClass: menu.overlayPanelClass,
      scrollStrategy: this._scrollStrategy(),
      direction: this._dir || "ltr",
      disableAnimations: this._animationsDisabled
    });
  }
  /**
   * Listens to changes in the position of the overlay and sets the correct classes
   * on the menu based on the new position. This ensures the animation origin is always
   * correct, even if a fallback position is used for the overlay.
   */
  _subscribeToPositions(menu, position) {
    if (menu.setPositionClasses) {
      position.positionChanges.subscribe((change) => {
        this._ngZone.run(() => {
          const posX = change.connectionPair.overlayX === "start" ? "after" : "before";
          const posY = change.connectionPair.overlayY === "top" ? "below" : "above";
          menu.setPositionClasses(posX, posY);
        });
      });
    }
  }
  /**
   * Sets the appropriate positions on a position strategy
   * so the overlay connects with the trigger correctly.
   * @param positionStrategy Strategy whose position to update.
   */
  _setPosition(menu, positionStrategy) {
    let [originX, originFallbackX] = menu.xPosition === "before" ? ["end", "start"] : ["start", "end"];
    let [overlayY, overlayFallbackY] = menu.yPosition === "above" ? ["bottom", "top"] : ["top", "bottom"];
    let [originY, originFallbackY] = [overlayY, overlayFallbackY];
    let [overlayX, overlayFallbackX] = [originX, originFallbackX];
    let offsetY = 0;
    if (this._triggersSubmenu()) {
      overlayFallbackX = originX = menu.xPosition === "before" ? "start" : "end";
      originFallbackX = overlayX = originX === "end" ? "start" : "end";
      if (this._parentMaterialMenu) {
        if (this._parentInnerPadding == null) {
          const firstItem = this._parentMaterialMenu.items.first;
          this._parentInnerPadding = firstItem ? firstItem._getHostElement().offsetTop : 0;
        }
        offsetY = overlayY === "bottom" ? this._parentInnerPadding : -this._parentInnerPadding;
      }
    } else if (!menu.overlapTrigger) {
      originY = overlayY === "top" ? "bottom" : "top";
      originFallbackY = overlayFallbackY === "top" ? "bottom" : "top";
    }
    positionStrategy.withPositions([{
      originX,
      originY,
      overlayX,
      overlayY,
      offsetY
    }, {
      originX: originFallbackX,
      originY,
      overlayX: overlayFallbackX,
      overlayY,
      offsetY
    }, {
      originX,
      originY: originFallbackY,
      overlayX,
      overlayY: overlayFallbackY,
      offsetY: -offsetY
    }, {
      originX: originFallbackX,
      originY: originFallbackY,
      overlayX: overlayFallbackX,
      overlayY: overlayFallbackY,
      offsetY: -offsetY
    }]);
  }
  /** Returns a stream that emits whenever an action that should close the menu occurs. */
  _menuClosingActions() {
    const outsideClicks = this._getOutsideClickStream(this._overlayRef);
    const detachments = this._overlayRef.detachments();
    const parentClose = this._parentMaterialMenu ? this._parentMaterialMenu.closed : of();
    const hover = this._parentMaterialMenu ? this._parentMaterialMenu._hovered().pipe(filter((active) => this._menuOpen && active !== this._menuItemInstance)) : of();
    return merge(outsideClicks, parentClose, hover, detachments);
  }
  /** Gets the portal that should be attached to the overlay. */
  _getPortal(menu) {
    if (!this._portal || this._portal.templateRef !== menu.templateRef) {
      this._portal = new TemplatePortal(menu.templateRef, this._viewContainerRef);
    }
    return this._portal;
  }
  /**
   * Determines whether the trigger owns a specific menu panel, at the current point in time.
   * This allows us to distinguish the case where the same panel is passed into multiple triggers
   * and multiple are open at a time.
   */
  _ownsMenu(menu) {
    return PANELS_TO_TRIGGERS.get(menu) === this;
  }
  static \u0275fac = function MatMenuTriggerBase_Factory(__ngFactoryType__) {
    \u0275\u0275invalidFactory();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _MatMenuTriggerBase
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatMenuTriggerBase, [{
    type: Directive
  }], () => [{
    type: void 0
  }], null);
})();
var MatMenuTrigger = class _MatMenuTrigger extends MatMenuTriggerBase {
  _cleanupTouchstart;
  _hoverSubscription = Subscription.EMPTY;
  /**
   * @deprecated
   * @breaking-change 8.0.0
   */
  get _deprecatedMatMenuTriggerFor() {
    return this.menu;
  }
  set _deprecatedMatMenuTriggerFor(v) {
    this.menu = v;
  }
  /** References the menu instance that the trigger is associated with. */
  get menu() {
    return this._menu;
  }
  set menu(menu) {
    this._menu = menu;
  }
  /** Data to be passed along to any lazily-rendered content. */
  menuData;
  /**
   * Whether focus should be restored when the menu is closed.
   * Note that disabling this option can have accessibility implications
   * and it's up to you to manage focus, if you decide to turn it off.
   */
  restoreFocus = true;
  /** Event emitted when the associated menu is opened. */
  menuOpened = new EventEmitter();
  /**
   * Event emitted when the associated menu is opened.
   * @deprecated Switch to `menuOpened` instead
   * @breaking-change 8.0.0
   */
  // tslint:disable-next-line:no-output-on-prefix
  onMenuOpen = this.menuOpened;
  /** Event emitted when the associated menu is closed. */
  menuClosed = new EventEmitter();
  /**
   * Event emitted when the associated menu is closed.
   * @deprecated Switch to `menuClosed` instead
   * @breaking-change 8.0.0
   */
  // tslint:disable-next-line:no-output-on-prefix
  onMenuClose = this.menuClosed;
  constructor() {
    super(true);
    const renderer = inject(Renderer2);
    this._cleanupTouchstart = renderer.listen(this._element.nativeElement, "touchstart", (event) => {
      if (!isFakeTouchstartFromScreenReader(event)) {
        this._openedBy = "touch";
      }
    }, {
      passive: true
    });
  }
  /** Whether the menu triggers a sub-menu or a top-level one. */
  triggersSubmenu() {
    return super._triggersSubmenu();
  }
  /** Toggles the menu between the open and closed states. */
  toggleMenu() {
    return this.menuOpen ? this.closeMenu() : this.openMenu();
  }
  /** Opens the menu. */
  openMenu() {
    this._openMenu(true);
  }
  /** Closes the menu. */
  closeMenu() {
    this._closeMenu();
  }
  /**
   * Updates the position of the menu to ensure that it fits all options within the viewport.
   */
  updatePosition() {
    this._overlayRef?.updatePosition();
  }
  ngAfterContentInit() {
    this._handleHover();
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this._cleanupTouchstart();
    this._hoverSubscription.unsubscribe();
  }
  _getOverlayOrigin() {
    return this._element;
  }
  _getOutsideClickStream(overlayRef) {
    return overlayRef.backdropClick();
  }
  /** Handles mouse presses on the trigger. */
  _handleMousedown(event) {
    if (!isFakeMousedownFromScreenReader(event)) {
      this._openedBy = event.button === 0 ? "mouse" : void 0;
      if (this.triggersSubmenu()) {
        event.preventDefault();
      }
    }
  }
  /** Handles key presses on the trigger. */
  _handleKeydown(event) {
    const keyCode = event.keyCode;
    if (keyCode === ENTER || keyCode === SPACE) {
      this._openedBy = "keyboard";
    }
    if (this.triggersSubmenu() && (keyCode === RIGHT_ARROW && this.dir === "ltr" || keyCode === LEFT_ARROW && this.dir === "rtl")) {
      this._openedBy = "keyboard";
      this.openMenu();
    }
  }
  /** Handles click events on the trigger. */
  _handleClick(event) {
    if (this.triggersSubmenu()) {
      event.stopPropagation();
      this.openMenu();
    } else {
      this.toggleMenu();
    }
  }
  /** Handles the cases where the user hovers over the trigger. */
  _handleHover() {
    if (this.triggersSubmenu() && this._parentMaterialMenu) {
      this._hoverSubscription = this._parentMaterialMenu._hovered().subscribe((active) => {
        if (active === this._menuItemInstance && !active.disabled && // Ignore hover events if the parent menu is in the process of being closed (see #31956).
        this._parentMaterialMenu?._panelAnimationState !== "void") {
          this._openedBy = "mouse";
          this._openMenu(false);
        }
      });
    }
  }
  static \u0275fac = function MatMenuTrigger_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatMenuTrigger)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _MatMenuTrigger,
    selectors: [["", "mat-menu-trigger-for", ""], ["", "matMenuTriggerFor", ""]],
    hostAttrs: [1, "mat-mdc-menu-trigger"],
    hostVars: 3,
    hostBindings: function MatMenuTrigger_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("click", function MatMenuTrigger_click_HostBindingHandler($event) {
          return ctx._handleClick($event);
        })("mousedown", function MatMenuTrigger_mousedown_HostBindingHandler($event) {
          return ctx._handleMousedown($event);
        })("keydown", function MatMenuTrigger_keydown_HostBindingHandler($event) {
          return ctx._handleKeydown($event);
        });
      }
      if (rf & 2) {
        \u0275\u0275attribute("aria-haspopup", ctx.menu ? "menu" : null)("aria-expanded", ctx.menuOpen)("aria-controls", ctx.menuOpen ? ctx.menu == null ? null : ctx.menu.panelId : null);
      }
    },
    inputs: {
      _deprecatedMatMenuTriggerFor: [0, "mat-menu-trigger-for", "_deprecatedMatMenuTriggerFor"],
      menu: [0, "matMenuTriggerFor", "menu"],
      menuData: [0, "matMenuTriggerData", "menuData"],
      restoreFocus: [0, "matMenuTriggerRestoreFocus", "restoreFocus"]
    },
    outputs: {
      menuOpened: "menuOpened",
      onMenuOpen: "onMenuOpen",
      menuClosed: "menuClosed",
      onMenuClose: "onMenuClose"
    },
    exportAs: ["matMenuTrigger"],
    features: [\u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatMenuTrigger, [{
    type: Directive,
    args: [{
      selector: "[mat-menu-trigger-for], [matMenuTriggerFor]",
      host: {
        "class": "mat-mdc-menu-trigger",
        "[attr.aria-haspopup]": 'menu ? "menu" : null',
        "[attr.aria-expanded]": "menuOpen",
        "[attr.aria-controls]": "menuOpen ? menu?.panelId : null",
        "(click)": "_handleClick($event)",
        "(mousedown)": "_handleMousedown($event)",
        "(keydown)": "_handleKeydown($event)"
      },
      exportAs: "matMenuTrigger"
    }]
  }], () => [], {
    _deprecatedMatMenuTriggerFor: [{
      type: Input,
      args: ["mat-menu-trigger-for"]
    }],
    menu: [{
      type: Input,
      args: ["matMenuTriggerFor"]
    }],
    menuData: [{
      type: Input,
      args: ["matMenuTriggerData"]
    }],
    restoreFocus: [{
      type: Input,
      args: ["matMenuTriggerRestoreFocus"]
    }],
    menuOpened: [{
      type: Output
    }],
    onMenuOpen: [{
      type: Output
    }],
    menuClosed: [{
      type: Output
    }],
    onMenuClose: [{
      type: Output
    }]
  });
})();
var MatContextMenuTrigger = class _MatContextMenuTrigger extends MatMenuTriggerBase {
  _point = {
    x: 0,
    y: 0,
    initialX: 0,
    initialY: 0,
    initialScrollX: 0,
    initialScrollY: 0
  };
  _triggerPressedControl = false;
  _rootNode;
  _document = inject(DOCUMENT);
  _viewportRuler = inject(ViewportRuler);
  _scrollDispatcher = inject(ScrollDispatcher);
  _scrollSubscription;
  /** References the menu instance that the trigger is associated with. */
  get menu() {
    return this._menu;
  }
  set menu(menu) {
    this._menu = menu;
  }
  /** Data to be passed along to any lazily-rendered content. */
  menuData;
  /**
   * Whether focus should be restored when the menu is closed.
   * Note that disabling this option can have accessibility implications
   * and it's up to you to manage focus, if you decide to turn it off.
   */
  restoreFocus = true;
  /** Whether the context menu is disabled. */
  disabled = false;
  /** Event emitted when the associated menu is opened. */
  menuOpened = new EventEmitter();
  /** Event emitted when the associated menu is closed. */
  menuClosed = new EventEmitter();
  constructor() {
    super(false);
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this._scrollSubscription?.unsubscribe();
  }
  /** Handler for `contextmenu` events. */
  _handleContextMenuEvent(event) {
    if (!this.disabled) {
      event.preventDefault();
      if (this.menuOpen) {
        this._initializePoint(event.clientX, event.clientY);
        this._updatePosition();
      } else {
        this._openContextMenu(event);
      }
    }
  }
  _destroyMenu(reason) {
    super._destroyMenu(reason);
    this._scrollSubscription?.unsubscribe();
  }
  _getOverlayOrigin() {
    return this._point;
  }
  _getOutsideClickStream(overlayRef) {
    return overlayRef.outsidePointerEvents().pipe(skipWhile((event, index) => {
      if (event.type === "contextmenu") {
        return this._isWithinMenuOrTrigger(_getEventTarget(event));
      } else if (event.type === "auxclick") {
        if (index === 0) {
          return true;
        }
        this._rootNode ??= _getShadowRoot(this._element.nativeElement) || this._document;
        return this._isWithinMenuOrTrigger(this._rootNode.elementFromPoint(event.clientX, event.clientY));
      }
      return this._triggerPressedControl && index === 0 && event.ctrlKey;
    }));
  }
  /** Checks whether an element is within the trigger or the opened overlay. */
  _isWithinMenuOrTrigger(target) {
    if (!target) {
      return false;
    }
    const element = this._element.nativeElement;
    if (target === element || element.contains(target)) {
      return true;
    }
    const overlay = this._overlayRef?.hostElement;
    return overlay === target || !!overlay?.contains(target);
  }
  /** Opens the context menu. */
  _openContextMenu(event) {
    if (event.button === 2) {
      this._openedBy = "mouse";
    } else {
      this._openedBy = event.button === 0 ? "keyboard" : void 0;
    }
    this._initializePoint(event.clientX, event.clientY);
    this._triggerPressedControl = event.ctrlKey;
    super._openMenu(true);
    this._scrollSubscription?.unsubscribe();
    this._scrollSubscription = this._scrollDispatcher.scrolled(0).subscribe(() => {
      const position = this._viewportRuler.getViewportScrollPosition();
      const point = this._point;
      point.y = point.initialY + (point.initialScrollY - position.top);
      point.x = point.initialX + (point.initialScrollX - position.left);
      this._updatePosition();
    });
  }
  /** Initializes the point representing the origin relative to which the menu will be rendered. */
  _initializePoint(x, y) {
    const scrollPosition = this._viewportRuler.getViewportScrollPosition();
    const point = this._point;
    point.x = point.initialX = x;
    point.y = point.initialY = y;
    point.initialScrollX = scrollPosition.left;
    point.initialScrollY = scrollPosition.top;
  }
  /** Refreshes the position of the overlay. */
  _updatePosition() {
    const overlayRef = this._overlayRef;
    if (overlayRef) {
      const positionStrategy = overlayRef.getConfig().positionStrategy;
      positionStrategy.setOrigin(this._point);
      overlayRef.updatePosition();
    }
  }
  static \u0275fac = function MatContextMenuTrigger_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatContextMenuTrigger)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _MatContextMenuTrigger,
    selectors: [["", "matContextMenuTriggerFor", ""]],
    hostAttrs: [1, "mat-context-menu-trigger"],
    hostVars: 3,
    hostBindings: function MatContextMenuTrigger_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("contextmenu", function MatContextMenuTrigger_contextmenu_HostBindingHandler($event) {
          return ctx._handleContextMenuEvent($event);
        });
      }
      if (rf & 2) {
        \u0275\u0275attribute("aria-controls", ctx.menuOpen ? ctx.menu == null ? null : ctx.menu.panelId : null);
        \u0275\u0275classProp("mat-context-menu-trigger-disabled", ctx.disabled);
      }
    },
    inputs: {
      menu: [0, "matContextMenuTriggerFor", "menu"],
      menuData: [0, "matContextMenuTriggerData", "menuData"],
      restoreFocus: [0, "matContextMenuTriggerRestoreFocus", "restoreFocus"],
      disabled: [2, "matContextMenuTriggerDisabled", "disabled", booleanAttribute]
    },
    outputs: {
      menuOpened: "menuOpened",
      menuClosed: "menuClosed"
    },
    exportAs: ["matContextMenuTrigger"],
    features: [\u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatContextMenuTrigger, [{
    type: Directive,
    args: [{
      selector: "[matContextMenuTriggerFor]",
      host: {
        "class": "mat-context-menu-trigger",
        "[class.mat-context-menu-trigger-disabled]": "disabled",
        "[attr.aria-controls]": "menuOpen ? menu?.panelId : null",
        "(contextmenu)": "_handleContextMenuEvent($event)"
      },
      exportAs: "matContextMenuTrigger"
    }]
  }], () => [], {
    menu: [{
      type: Input,
      args: [{
        alias: "matContextMenuTriggerFor",
        required: true
      }]
    }],
    menuData: [{
      type: Input,
      args: ["matContextMenuTriggerData"]
    }],
    restoreFocus: [{
      type: Input,
      args: ["matContextMenuTriggerRestoreFocus"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "matContextMenuTriggerDisabled",
        transform: booleanAttribute
      }]
    }],
    menuOpened: [{
      type: Output
    }],
    menuClosed: [{
      type: Output
    }]
  });
})();
var MatMenuModule = class _MatMenuModule {
  static \u0275fac = function MatMenuModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MatMenuModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _MatMenuModule,
    imports: [MatRippleModule, MatCommonModule, OverlayModule, MatMenu, MatMenuItem, MatMenuContent, MatMenuTrigger, MatContextMenuTrigger],
    exports: [CdkScrollableModule, MatMenu, MatCommonModule, MatMenuItem, MatMenuContent, MatMenuTrigger, MatContextMenuTrigger]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER],
    imports: [MatRippleModule, MatCommonModule, OverlayModule, CdkScrollableModule, MatCommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatMenuModule, [{
    type: NgModule,
    args: [{
      imports: [MatRippleModule, MatCommonModule, OverlayModule, MatMenu, MatMenuItem, MatMenuContent, MatMenuTrigger, MatContextMenuTrigger],
      exports: [CdkScrollableModule, MatMenu, MatCommonModule, MatMenuItem, MatMenuContent, MatMenuTrigger, MatContextMenuTrigger],
      providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER]
    }]
  }], null, null);
})();
var matMenuAnimations = {
  // Represents:
  // trigger('transformMenu', [
  //   state(
  //     'void',
  //     style({
  //       opacity: 0,
  //       transform: 'scale(0.8)',
  //     }),
  //   ),
  //   transition(
  //     'void => enter',
  //     animate(
  //       '120ms cubic-bezier(0, 0, 0.2, 1)',
  //       style({
  //         opacity: 1,
  //         transform: 'scale(1)',
  //       }),
  //     ),
  //   ),
  //   transition('* => void', animate('100ms 25ms linear', style({opacity: 0}))),
  // ])
  /**
   * This animation controls the menu panel's entry and exit from the page.
   *
   * When the menu panel is added to the DOM, it scales in and fades in its border.
   *
   * When the menu panel is removed from the DOM, it simply fades out after a brief
   * delay to display the ripple.
   */
  transformMenu: {
    type: 7,
    name: "transformMenu",
    definitions: [{
      type: 0,
      name: "void",
      styles: {
        type: 6,
        styles: {
          opacity: 0,
          transform: "scale(0.8)"
        },
        offset: null
      }
    }, {
      type: 1,
      expr: "void => enter",
      animation: {
        type: 4,
        styles: {
          type: 6,
          styles: {
            opacity: 1,
            transform: "scale(1)"
          },
          offset: null
        },
        timings: "120ms cubic-bezier(0, 0, 0.2, 1)"
      },
      options: null
    }, {
      type: 1,
      expr: "* => void",
      animation: {
        type: 4,
        styles: {
          type: 6,
          styles: {
            opacity: 0
          },
          offset: null
        },
        timings: "100ms 25ms linear"
      },
      options: null
    }],
    options: {}
  },
  // Represents:
  // trigger('fadeInItems', [
  //   // TODO(crisbeto): this is inside the `transformMenu`
  //   // now. Remove next time we do breaking changes.
  //   state('showing', style({opacity: 1})),
  //   transition('void => *', [
  //     style({opacity: 0}),
  //     animate('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)'),
  //   ]),
  // ])
  /**
   * This animation fades in the background color and content of the menu panel
   * after its containing element is scaled in.
   */
  fadeInItems: {
    type: 7,
    name: "fadeInItems",
    definitions: [{
      type: 0,
      name: "showing",
      styles: {
        type: 6,
        styles: {
          opacity: 1
        },
        offset: null
      }
    }, {
      type: 1,
      expr: "void => *",
      animation: [{
        type: 6,
        styles: {
          opacity: 0
        },
        offset: null
      }, {
        type: 4,
        styles: null,
        timings: "400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)"
      }],
      options: null
    }],
    options: {}
  }
};
var fadeInItems = matMenuAnimations.fadeInItems;
var transformMenu = matMenuAnimations.transformMenu;

// projects/c3-components/src/lib/c3-prevent-event/c3-stop-click-propagation.directive.ts
var _C3StopPropagationDirective = class _C3StopPropagationDirective {
  onClick(event) {
    event.stopImmediatePropagation();
  }
};
_C3StopPropagationDirective.\u0275fac = function C3StopPropagationDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _C3StopPropagationDirective)();
};
_C3StopPropagationDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({ type: _C3StopPropagationDirective, selectors: [["", "c3-stop-click-propagation", ""]], hostBindings: function C3StopPropagationDirective_HostBindings(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275listener("click", function C3StopPropagationDirective_click_HostBindingHandler($event) {
      return ctx.onClick($event);
    });
  }
} });
var C3StopPropagationDirective = _C3StopPropagationDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(C3StopPropagationDirective, [{
    type: Directive,
    args: [{
      selector: "[c3-stop-click-propagation]",
      standalone: true
    }]
  }], null, { onClick: [{
    type: HostListener,
    args: ["click", ["$event"]]
  }] });
})();

// projects/c3-components/src/lib/c3-file-displayer/c3-file-display-list/tokens.ts
var C3_FILE_DISPLAY_LIST = new InjectionToken("C3_FILE_DISPLAY_LIST");

// projects/c3-components/src/lib/c3-file-displayer/c3-file-display-list/c3-file-display-list-column-def.directive.ts
var _C3FileDisplayListColumnDefDirective = class _C3FileDisplayListColumnDefDirective {
  constructor() {
    this.title = input.required(...ngDevMode ? [{ debugName: "title", alias: "c3FileDisplayListColumnDef" }] : [{
      alias: "c3FileDisplayListColumnDef"
    }]);
    this.classList = input([], ...ngDevMode ? [{ debugName: "classList" }] : []);
    this._table = inject(C3_FILE_DISPLAY_LIST, { optional: true });
    this.headerCellDef = contentChild(C3FileDisplayListHeaderCellDefDirective, ...ngDevMode ? [{ debugName: "headerCellDef" }] : []);
    this.cellDef = contentChild(C3FileDisplayListCellDefDirective, ...ngDevMode ? [{ debugName: "cellDef" }] : []);
  }
};
_C3FileDisplayListColumnDefDirective.\u0275fac = function C3FileDisplayListColumnDefDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _C3FileDisplayListColumnDefDirective)();
};
_C3FileDisplayListColumnDefDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({ type: _C3FileDisplayListColumnDefDirective, selectors: [["", "c3FileDisplayListColumnDef", ""]], contentQueries: function C3FileDisplayListColumnDefDirective_ContentQueries(rf, ctx, dirIndex) {
  if (rf & 1) {
    \u0275\u0275contentQuerySignal(dirIndex, ctx.headerCellDef, C3FileDisplayListHeaderCellDefDirective, 5);
    \u0275\u0275contentQuerySignal(dirIndex, ctx.cellDef, C3FileDisplayListCellDefDirective, 5);
  }
  if (rf & 2) {
    \u0275\u0275queryAdvance(2);
  }
}, inputs: { title: [1, "c3FileDisplayListColumnDef", "title"], classList: [1, "classList"] } });
var C3FileDisplayListColumnDefDirective = _C3FileDisplayListColumnDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(C3FileDisplayListColumnDefDirective, [{
    type: Directive,
    args: [{
      selector: "[c3FileDisplayListColumnDef]"
    }]
  }], null, { title: [{ type: Input, args: [{ isSignal: true, alias: "c3FileDisplayListColumnDef", required: true }] }], classList: [{ type: Input, args: [{ isSignal: true, alias: "classList", required: false }] }], headerCellDef: [{ type: ContentChild, args: [forwardRef(() => C3FileDisplayListHeaderCellDefDirective), { isSignal: true }] }], cellDef: [{ type: ContentChild, args: [forwardRef(() => C3FileDisplayListCellDefDirective), { isSignal: true }] }] });
})();
var _C3FileDisplayListHeaderCellDefDirective = class _C3FileDisplayListHeaderCellDefDirective {
  constructor() {
    this.template = inject(TemplateRef);
  }
};
_C3FileDisplayListHeaderCellDefDirective.\u0275fac = function C3FileDisplayListHeaderCellDefDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _C3FileDisplayListHeaderCellDefDirective)();
};
_C3FileDisplayListHeaderCellDefDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({ type: _C3FileDisplayListHeaderCellDefDirective, selectors: [["", "c3FileDisplayListHeaderCellDef", ""]] });
var C3FileDisplayListHeaderCellDefDirective = _C3FileDisplayListHeaderCellDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(C3FileDisplayListHeaderCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[c3FileDisplayListHeaderCellDef]"
    }]
  }], null, null);
})();
var _C3FileDisplayListCellDefDirective = class _C3FileDisplayListCellDefDirective {
  constructor() {
    this.template = inject(TemplateRef);
  }
};
_C3FileDisplayListCellDefDirective.\u0275fac = function C3FileDisplayListCellDefDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _C3FileDisplayListCellDefDirective)();
};
_C3FileDisplayListCellDefDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({ type: _C3FileDisplayListCellDefDirective, selectors: [["", "c3FileDisplayListCellDef", ""]] });
var C3FileDisplayListCellDefDirective = _C3FileDisplayListCellDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(C3FileDisplayListCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[c3FileDisplayListCellDef]"
    }]
  }], null, null);
})();

// projects/c3-components/src/lib/c3-file-displayer/c3-file-display-list/c3-file-display-list.component.ts
var _c02 = ["*"];
var _c12 = (a0) => ({ $implicit: a0 });
function C3FileDisplayListComponent_For_5_Conditional_1_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function C3FileDisplayListComponent_For_5_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, C3FileDisplayListComponent_For_5_Conditional_1_ng_container_0_Template, 1, 0, "ng-container", 5);
  }
  if (rf & 2) {
    const columnName_r1 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.getColumnDef(columnName_r1).headerCellDef().template);
  }
}
function C3FileDisplayListComponent_For_5_Conditional_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span");
  }
}
function C3FileDisplayListComponent_For_5_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1, "Nom");
    \u0275\u0275elementEnd();
  }
}
function C3FileDisplayListComponent_For_5_Conditional_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1, "Date d'ajout");
    \u0275\u0275elementEnd();
  }
}
function C3FileDisplayListComponent_For_5_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, C3FileDisplayListComponent_For_5_Conditional_2_Conditional_0_Template, 1, 0, "span")(1, C3FileDisplayListComponent_For_5_Conditional_2_Conditional_1_Template, 2, 0, "span")(2, C3FileDisplayListComponent_For_5_Conditional_2_Conditional_2_Template, 2, 0, "span");
  }
  if (rf & 2) {
    const columnName_r1 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275conditional(columnName_r1 === "icon" ? 0 : columnName_r1 === "name" ? 1 : columnName_r1 === "date" ? 2 : -1);
  }
}
function C3FileDisplayListComponent_For_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "th");
    \u0275\u0275conditionalCreate(1, C3FileDisplayListComponent_For_5_Conditional_1_Template, 1, 1, "ng-container")(2, C3FileDisplayListComponent_For_5_Conditional_2_Template, 3, 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_12_0;
    const columnName_r1 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classProp("full", columnName_r1 === "name")("icon", columnName_r1 === "icon");
    \u0275\u0275advance();
    \u0275\u0275conditional(((tmp_12_0 = ctx_r1.getColumnDef(columnName_r1)) == null ? null : tmp_12_0.headerCellDef()) ? 1 : 2);
  }
}
function C3FileDisplayListComponent_For_10_For_2_Conditional_0_Conditional_1_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function C3FileDisplayListComponent_For_10_For_2_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, C3FileDisplayListComponent_For_10_For_2_Conditional_0_Conditional_1_ng_container_0_Template, 1, 0, "ng-container", 13);
  }
  if (rf & 2) {
    const columnName_r5 = \u0275\u0275nextContext(2).$implicit;
    const file_r6 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.getColumnDef(columnName_r5).cellDef().template)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c12, file_r6));
  }
}
function C3FileDisplayListComponent_For_10_For_2_Conditional_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const file_r6 = \u0275\u0275nextContext(3).$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r1.displayFn()(file_r6));
  }
}
function C3FileDisplayListComponent_For_10_For_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "td", 10);
    \u0275\u0275conditionalCreate(1, C3FileDisplayListComponent_For_10_For_2_Conditional_0_Conditional_1_Template, 1, 4, "ng-container")(2, C3FileDisplayListComponent_For_10_For_2_Conditional_0_Conditional_2_Template, 2, 1, "span");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_22_0;
    const columnName_r5 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275conditional(((tmp_22_0 = ctx_r1.getColumnDef(columnName_r5)) == null ? null : tmp_22_0.cellDef()) ? 1 : 2);
  }
}
function C3FileDisplayListComponent_For_10_For_2_Conditional_1_Conditional_1_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function C3FileDisplayListComponent_For_10_For_2_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, C3FileDisplayListComponent_For_10_For_2_Conditional_1_Conditional_1_ng_container_0_Template, 1, 0, "ng-container", 13);
  }
  if (rf & 2) {
    const columnName_r5 = \u0275\u0275nextContext(2).$implicit;
    const file_r6 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.getColumnDef(columnName_r5).cellDef().template)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c12, file_r6));
  }
}
function C3FileDisplayListComponent_For_10_For_2_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "c3-file-display-icon", 14);
  }
  if (rf & 2) {
    const file_r6 = \u0275\u0275nextContext(3).$implicit;
    \u0275\u0275property("fileType", file_r6.type);
  }
}
function C3FileDisplayListComponent_For_10_For_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "td", 11);
    \u0275\u0275conditionalCreate(1, C3FileDisplayListComponent_For_10_For_2_Conditional_1_Conditional_1_Template, 1, 4, "ng-container")(2, C3FileDisplayListComponent_For_10_For_2_Conditional_1_Conditional_2_Template, 1, 1, "c3-file-display-icon", 14);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_22_0;
    const columnName_r5 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275conditional(((tmp_22_0 = ctx_r1.getColumnDef(columnName_r5)) == null ? null : tmp_22_0.cellDef()) ? 1 : 2);
  }
}
function C3FileDisplayListComponent_For_10_For_2_Conditional_2_Conditional_1_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function C3FileDisplayListComponent_For_10_For_2_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, C3FileDisplayListComponent_For_10_For_2_Conditional_2_Conditional_1_ng_container_0_Template, 1, 0, "ng-container", 13);
  }
  if (rf & 2) {
    const columnName_r5 = \u0275\u0275nextContext(2).$implicit;
    const file_r6 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.getColumnDef(columnName_r5).cellDef().template)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c12, file_r6));
  }
}
function C3FileDisplayListComponent_For_10_For_2_Conditional_2_Conditional_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "date");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const file_r6 = \u0275\u0275nextContext(4).$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(file_r6.lastModified ? \u0275\u0275pipeBind2(2, 1, file_r6.lastModified, "medium") : "-");
  }
}
function C3FileDisplayListComponent_For_10_For_2_Conditional_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, C3FileDisplayListComponent_For_10_For_2_Conditional_2_Conditional_2_Conditional_0_Template, 3, 4, "span");
  }
  if (rf & 2) {
    const columnName_r5 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275conditional(columnName_r5 === "date" ? 0 : -1);
  }
}
function C3FileDisplayListComponent_For_10_For_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "td", 12);
    \u0275\u0275conditionalCreate(1, C3FileDisplayListComponent_For_10_For_2_Conditional_2_Conditional_1_Template, 1, 4, "ng-container")(2, C3FileDisplayListComponent_For_10_For_2_Conditional_2_Conditional_2_Template, 1, 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_22_0;
    let tmp_23_0;
    const columnName_r5 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("classList", (tmp_22_0 = ctx_r1.getColumnDef(columnName_r5)) == null ? null : tmp_22_0.classList());
    \u0275\u0275advance();
    \u0275\u0275conditional(((tmp_23_0 = ctx_r1.getColumnDef(columnName_r5)) == null ? null : tmp_23_0.cellDef()) ? 1 : 2);
  }
}
function C3FileDisplayListComponent_For_10_For_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, C3FileDisplayListComponent_For_10_For_2_Conditional_0_Template, 3, 1, "td", 10)(1, C3FileDisplayListComponent_For_10_For_2_Conditional_1_Template, 3, 1, "td", 11)(2, C3FileDisplayListComponent_For_10_For_2_Conditional_2_Template, 3, 2, "td", 12);
  }
  if (rf & 2) {
    const columnName_r5 = ctx.$implicit;
    \u0275\u0275conditional(columnName_r5 === "name" ? 0 : columnName_r5 === "icon" ? 1 : 2);
  }
}
function C3FileDisplayListComponent_For_10_Conditional_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 8);
    \u0275\u0275listener("click", function C3FileDisplayListComponent_For_10_Conditional_13_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r7);
      const file_r6 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onDelete.emit(file_r6));
    });
    \u0275\u0275text(1, "Supprimer");
    \u0275\u0275elementEnd();
  }
}
function C3FileDisplayListComponent_For_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "tr", 6);
    \u0275\u0275listener("click", function C3FileDisplayListComponent_For_10_Template_tr_click_0_listener($event) {
      const $index_r4 = \u0275\u0275restoreView(_r3).$index;
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.openDialog($event, $index_r4));
    });
    \u0275\u0275repeaterCreate(1, C3FileDisplayListComponent_For_10_For_2_Template, 3, 1, null, null, \u0275\u0275repeaterTrackByIdentity);
    \u0275\u0275elementStart(3, "td", 4)(4, "button", 7)(5, "mat-icon");
    \u0275\u0275text(6, "more_vert");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "mat-menu", null, 0)(9, "button", 8);
    \u0275\u0275listener("click", function C3FileDisplayListComponent_For_10_Template_button_click_9_listener($event) {
      const $index_r4 = \u0275\u0275restoreView(_r3).$index;
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.openDialog($event, $index_r4));
    });
    \u0275\u0275text(10, " Ouvrir ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "button", 8);
    \u0275\u0275listener("click", function C3FileDisplayListComponent_For_10_Template_button_click_11_listener() {
      const file_r6 = \u0275\u0275restoreView(_r3).$implicit;
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.fileViewer.download(file_r6));
    });
    \u0275\u0275text(12, "T\xE9l\xE9charger");
    \u0275\u0275elementEnd();
    \u0275\u0275conditionalCreate(13, C3FileDisplayListComponent_For_10_Conditional_13_Template, 2, 0, "button", 9);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const menu_r8 = \u0275\u0275reference(8);
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r1.columns());
    \u0275\u0275advance(3);
    \u0275\u0275property("matMenuTriggerFor", menu_r8);
    \u0275\u0275advance(9);
    \u0275\u0275conditional(ctx_r1.deletable() ? 13 : -1);
  }
}
var _C3FileDisplayListComponent = class _C3FileDisplayListComponent {
  constructor() {
    this.files = input.required(...ngDevMode ? [{ debugName: "files" }] : []);
    this.config = input(...ngDevMode ? [void 0, { debugName: "config" }] : []);
    this.displayFn = input((file) => file.name, ...ngDevMode ? [{ debugName: "displayFn" }] : []);
    this.columns = input(["icon", "name", "date"], ...ngDevMode ? [{ debugName: "columns" }] : []);
    this.deletable = input(false, ...ngDevMode ? [{ debugName: "deletable" }] : []);
    this.onDelete = output();
    this.dialog = viewChild(C3FileViewerDialogComponent, ...ngDevMode ? [{ debugName: "dialog" }] : []);
    this._columnDefs = contentChildren(C3FileDisplayListColumnDefDirective, ...ngDevMode ? [{ debugName: "_columnDefs" }] : []);
    this._viewContainer = inject(ViewContainerRef);
    this.fileViewer = new C3FileViewer({
      client: inject(HttpClient)
    });
    effect(() => {
      this.fileViewer.files = this.files();
    });
    effect(() => {
      if (this.config())
        this.fileViewer.config = this.config();
    });
  }
  openDialog($event, index) {
    $event.stopPropagation();
    this.fileViewer.currentIndex = index;
    this.dialog()?.openDialog();
  }
  getColumnDef(columnName) {
    return this._columnDefs().find((col) => col.title() === columnName);
  }
};
_C3FileDisplayListComponent.\u0275fac = function C3FileDisplayListComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _C3FileDisplayListComponent)();
};
_C3FileDisplayListComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _C3FileDisplayListComponent, selectors: [["c3-file-display-list"]], contentQueries: function C3FileDisplayListComponent_ContentQueries(rf, ctx, dirIndex) {
  if (rf & 1) {
    \u0275\u0275contentQuerySignal(dirIndex, ctx._columnDefs, C3FileDisplayListColumnDefDirective, 4);
  }
  if (rf & 2) {
    \u0275\u0275queryAdvance();
  }
}, viewQuery: function C3FileDisplayListComponent_Query(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275viewQuerySignal(ctx.dialog, C3FileViewerDialogComponent, 5);
  }
  if (rf & 2) {
    \u0275\u0275queryAdvance();
  }
}, inputs: { files: [1, "files"], config: [1, "config"], displayFn: [1, "displayFn"], columns: [1, "columns"], deletable: [1, "deletable"] }, outputs: { onDelete: "onDelete" }, features: [\u0275\u0275ProvidersFeature([
  {
    provide: C3_FILE_DISPLAY_LIST,
    useExisting: _C3FileDisplayListComponent
  }
])], ngContentSelectors: _c02, decls: 11, vars: 1, consts: [["menu", "matMenu"], [3, "fileViewer"], [1, "file-table"], [3, "full", "icon"], [1, "actions"], [4, "ngTemplateOutlet"], [3, "click"], ["mat-icon-button", "", "c3-stop-click-propagation", "", 3, "matMenuTriggerFor"], ["mat-menu-item", "", 3, "click"], ["mat-menu-item", ""], [1, "name", "full"], [1, "icon"], [3, "classList"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "fileType"]], template: function C3FileDisplayListComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projectionDef();
    \u0275\u0275elementStart(0, "c3-file-viewer-dialog", 1)(1, "table", 2)(2, "thead")(3, "tr");
    \u0275\u0275repeaterCreate(4, C3FileDisplayListComponent_For_5_Template, 3, 5, "th", 3, \u0275\u0275repeaterTrackByIdentity);
    \u0275\u0275elementStart(6, "th", 4);
    \u0275\u0275projection(7);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(8, "tbody");
    \u0275\u0275repeaterCreate(9, C3FileDisplayListComponent_For_10_Template, 14, 2, "tr", null, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    \u0275\u0275property("fileViewer", ctx.fileViewer);
    \u0275\u0275advance(4);
    \u0275\u0275repeater(ctx.columns());
    \u0275\u0275advance(5);
    \u0275\u0275repeater(ctx.files());
  }
}, dependencies: [
  C3StopPropagationDirective,
  C3FileViewerModule,
  C3FileViewerDialogComponent,
  C3FileDisplayIconComponent,
  CommonModule,
  NgTemplateOutlet,
  MatButtonModule,
  MatIconButton,
  MatIconModule,
  MatIcon,
  MatNativeDateModule,
  MatMenuModule,
  MatMenu,
  MatMenuItem,
  MatMenuTrigger,
  DatePipe
], styles: ["\n\n[_nghost-%COMP%] {\n  display: flex;\n  flex-direction: column;\n  margin: 0.5rem;\n}\n[_nghost-%COMP%]   .file-table[_ngcontent-%COMP%] {\n  width: 100%;\n  border-collapse: collapse;\n}\n[_nghost-%COMP%]   .file-table[_ngcontent-%COMP%]   th[_ngcontent-%COMP%], \n[_nghost-%COMP%]   .file-table[_ngcontent-%COMP%]   td[_ngcontent-%COMP%] {\n  padding: 0.5rem;\n  text-align: left;\n  border-bottom: 1px solid var(--mat-divider-color);\n}\n[_nghost-%COMP%]   .file-table[_ngcontent-%COMP%]   th[_ngcontent-%COMP%] {\n  font-size: 1.5rem;\n  font-weight: bold;\n  background-color: var(--mat-table-header-container-background-color);\n}\n[_nghost-%COMP%]   .file-table[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]:hover {\n  background-color: var(--background-hover);\n}\n[_nghost-%COMP%]   .file-table[_ngcontent-%COMP%]   .icon[_ngcontent-%COMP%] {\n  width: 56px;\n  min-width: 56px;\n  text-align: center;\n}\n[_nghost-%COMP%]   .file-table[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:where(th, td):not(.full) {\n  width: 0;\n  white-space: nowrap;\n}\n[_nghost-%COMP%]   .file-table[_ngcontent-%COMP%]   .actions[_ngcontent-%COMP%] {\n  width: 48px;\n  text-align: center;\n}\n/*# sourceMappingURL=c3-file-display-list.component.css.map */"] });
var C3FileDisplayListComponent = _C3FileDisplayListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(C3FileDisplayListComponent, [{
    type: Component,
    args: [{ selector: "c3-file-display-list", imports: [
      C3StopPropagationDirective,
      C3FileViewerModule,
      C3FileDisplayIconComponent,
      CommonModule,
      MatButtonModule,
      MatIconModule,
      MatNativeDateModule,
      MatMenuModule
    ], providers: [
      {
        provide: C3_FILE_DISPLAY_LIST,
        useExisting: C3FileDisplayListComponent
      }
    ], template: `<c3-file-viewer-dialog [fileViewer]="fileViewer">
<!-- header -->
  <table class="file-table">
    <thead>
      <tr>
        @for (columnName of columns(); track columnName) {
          <th [class.full]="columnName === 'name'" [class.icon]="columnName === 'icon'">
            @if (getColumnDef(columnName)?.headerCellDef()) {
              <ng-container *ngTemplateOutlet="getColumnDef(columnName)!.headerCellDef()!.template"></ng-container>
            } @else {
              @if (columnName === 'icon') {
                <span></span>
              } @else if (columnName === 'name') {
                <span>Nom</span>
              } @else if (columnName === 'date') {
                <span>Date d'ajout</span>
              }
            }
          </th>
        }
        <th class="actions">
          <ng-content></ng-content>
        </th>
      </tr>
    </thead>
    <tbody>
      @for (file of files(); track $index) {
        <tr (click)="openDialog($event, $index)">
          @for (columnName of columns(); track columnName) {
            @if (columnName === 'name') {
              <td class="name full">
                @if (getColumnDef(columnName)?.cellDef()) {
                  <ng-container *ngTemplateOutlet="getColumnDef(columnName)!.cellDef()!.template; context: { $implicit: file }"></ng-container>
                } @else {
                  <span>{{ displayFn()(file) }}</span>
                }
              </td>
            } @else if (columnName === 'icon') {
              <td class="icon">
                @if (getColumnDef(columnName)?.cellDef()) {
                  <ng-container *ngTemplateOutlet="getColumnDef(columnName)!.cellDef()!.template; context: { $implicit: file }"></ng-container>
                } @else {
                  <c3-file-display-icon [fileType]="file.type" />
                }
              </td>
            } @else {
              <td [classList]="getColumnDef(columnName)?.classList()">
                @if (getColumnDef(columnName)?.cellDef()) {
                  <ng-container *ngTemplateOutlet="getColumnDef(columnName)!.cellDef()!.template; context: { $implicit: file }"></ng-container>
                } @else {
                  @if (columnName === 'date') {
                    <span>{{ file.lastModified ? (file.lastModified | date:'medium') : '-' }}</span>
                  }
                }
              </td>
            }
          }
          <td class="actions">
            <button mat-icon-button [matMenuTriggerFor]="menu" c3-stop-click-propagation>
              <mat-icon>more_vert</mat-icon>
            </button>
            <mat-menu #menu="matMenu">
              <button mat-menu-item (click)="openDialog($event, $index)">
                Ouvrir
              </button>
              <button mat-menu-item (click)="fileViewer.download(file)">T\xE9l\xE9charger</button>
              @if (deletable()) {
                <button mat-menu-item (click)="onDelete.emit(file)">Supprimer</button>
              }
            </mat-menu>
          </td>
        </tr>
      }
    </tbody>
  </table>
</c3-file-viewer-dialog>

<!-- <div class="file-display-list">
  @for (file of files(); track $index) {
  <button>
    @for (columnName of columns(); track columnName) {
      @if (columnName === 'name') {
        <div class="name">
          @if (getColumnDef(columnName)?.cellDef()) {
            <ng-container *ngTemplateOutlet="getColumnDef(columnName)!.cellDef()!.template; context: { $implicit: file }"></ng-container>
          } @else {
            <span>{{ displayFn()(file) }}</span>
          }
        </div>
      } @else if (columnName === 'icon') {
        <div class="icon-cell">
          @if (getColumnDef(columnName)?.cellDef()) {
            <ng-container *ngTemplateOutlet="getColumnDef(columnName)!.cellDef()!.template; context: { $implicit: file }"></ng-container>
          } @else {
            <div class="icon">
              <c3-file-display-icon [fileType]="file.type" />
            </div>
          }
        </div>
      } @else {
        <div class="cell">
          @if (getColumnDef(columnName)?.cellDef()) {
            <ng-container *ngTemplateOutlet="getColumnDef(columnName)!.cellDef()!.template; context: { $implicit: file }"></ng-container>
          } @else {
            @if (columnName === 'date') {
              <div class="date-label">
                <span>{{ file.lastModified ? (file.lastModified | date:'medium') : '-' }}</span>
              </div>
            }
          }
        </div>
      }
    }
    <button mat-icon-button [matMenuTriggerFor]="menu" c3-stop-click-propagation>
      <mat-icon>more_vert</mat-icon>
    </button>
    <mat-menu #menu="matMenu">
      <button mat-menu-item (click)="openDialog($event, $index)">
        Ouvrir
      </button>
      @if (deletable()) {
      <button mat-menu-item (click)="onDelete.emit(file)">Supprimer</button>
      }
    </mat-menu>
  </button>
  }
</div> -->
`, styles: ["/* projects/c3-components/src/lib/c3-file-displayer/c3-file-display-list/c3-file-display-list.component.scss */\n:host {\n  display: flex;\n  flex-direction: column;\n  margin: 0.5rem;\n}\n:host .file-table {\n  width: 100%;\n  border-collapse: collapse;\n}\n:host .file-table th,\n:host .file-table td {\n  padding: 0.5rem;\n  text-align: left;\n  border-bottom: 1px solid var(--mat-divider-color);\n}\n:host .file-table th {\n  font-size: 1.5rem;\n  font-weight: bold;\n  background-color: var(--mat-table-header-container-background-color);\n}\n:host .file-table tr:hover {\n  background-color: var(--background-hover);\n}\n:host .file-table .icon {\n  width: 56px;\n  min-width: 56px;\n  text-align: center;\n}\n:host .file-table :where(th, td):not(.full) {\n  width: 0;\n  white-space: nowrap;\n}\n:host .file-table .actions {\n  width: 48px;\n  text-align: center;\n}\n/*# sourceMappingURL=c3-file-display-list.component.css.map */\n"] }]
  }], () => [], { files: [{ type: Input, args: [{ isSignal: true, alias: "files", required: true }] }], config: [{ type: Input, args: [{ isSignal: true, alias: "config", required: false }] }], displayFn: [{ type: Input, args: [{ isSignal: true, alias: "displayFn", required: false }] }], columns: [{ type: Input, args: [{ isSignal: true, alias: "columns", required: false }] }], deletable: [{ type: Input, args: [{ isSignal: true, alias: "deletable", required: false }] }], onDelete: [{ type: Output, args: ["onDelete"] }], dialog: [{ type: ViewChild, args: [forwardRef(() => C3FileViewerDialogComponent), { isSignal: true }] }], _columnDefs: [{ type: ContentChildren, args: [forwardRef(() => C3FileDisplayListColumnDefDirective), { isSignal: true }] }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(C3FileDisplayListComponent, { className: "C3FileDisplayListComponent", filePath: "projects/c3-components/src/lib/c3-file-displayer/c3-file-display-list/c3-file-display-list.component.ts", lineNumber: 49 });
})();

// projects/c3-components/src/lib/c3-file-displayer/c3-file-displayer.module.ts
var _C3FileDisplayerModule = class _C3FileDisplayerModule {
};
_C3FileDisplayerModule.\u0275fac = function C3FileDisplayerModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _C3FileDisplayerModule)();
};
_C3FileDisplayerModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _C3FileDisplayerModule });
_C3FileDisplayerModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({ imports: [
  CommonModule,
  C3FileDisplayGridComponent,
  C3FileDisplayListComponent,
  C3FileDisplayCardComponent,
  C3FileDisplayIconComponent
] });
var C3FileDisplayerModule = _C3FileDisplayerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(C3FileDisplayerModule, [{
    type: NgModule,
    args: [{
      declarations: [],
      imports: [
        CommonModule,
        C3FileDisplayGridComponent,
        C3FileDisplayListComponent,
        C3FileDisplayCardComponent,
        C3FileDisplayIconComponent,
        C3FileDisplayListColumnDefDirective,
        C3FileDisplayListHeaderCellDefDirective,
        C3FileDisplayListCellDefDirective
      ],
      exports: [
        C3FileDisplayGridComponent,
        C3FileDisplayListComponent,
        C3FileDisplayCardComponent,
        C3FileDisplayIconComponent,
        C3FileDisplayListColumnDefDirective,
        C3FileDisplayListHeaderCellDefDirective,
        C3FileDisplayListCellDefDirective
      ]
    }]
  }], null, null);
})();

// projects/c3-components-docs/src/app/pages/docs/pages/file-displayer/components/example-display-grid/example-display-grid.component.ts
var _ExampleDisplayGridComponent = class _ExampleDisplayGridComponent {
  constructor() {
    this.files = signal(crabbyImgs, ...ngDevMode ? [{ debugName: "files" }] : []);
    this.config = signal(configDemo, ...ngDevMode ? [{ debugName: "config" }] : []);
  }
};
_ExampleDisplayGridComponent.\u0275fac = function ExampleDisplayGridComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ExampleDisplayGridComponent)();
};
_ExampleDisplayGridComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ExampleDisplayGridComponent, selectors: [["c3-example-display-grid"]], decls: 1, vars: 2, consts: [[3, "files", "config"]], template: function ExampleDisplayGridComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "c3-file-display-grid", 0);
  }
  if (rf & 2) {
    \u0275\u0275property("files", ctx.files())("config", ctx.config());
  }
}, dependencies: [C3FileDisplayerModule, C3FileDisplayGridComponent], styles: ["\n\n[_nghost-%COMP%] {\n  display: block;\n}\n/*# sourceMappingURL=example-display-grid.component.css.map */"] });
var ExampleDisplayGridComponent = _ExampleDisplayGridComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExampleDisplayGridComponent, [{
    type: Component,
    args: [{ selector: "c3-example-display-grid", imports: [C3FileDisplayerModule], template: '<c3-file-display-grid [files]="files()" [config]="config()" />\n', styles: ["/* projects/c3-components-docs/src/app/pages/docs/pages/file-displayer/components/example-display-grid/example-display-grid.component.scss */\n:host {\n  display: block;\n}\n/*# sourceMappingURL=example-display-grid.component.css.map */\n"] }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ExampleDisplayGridComponent, { className: "ExampleDisplayGridComponent", filePath: "projects/c3-components-docs/src/app/pages/docs/pages/file-displayer/components/example-display-grid/example-display-grid.component.ts", lineNumber: 15 });
})();

// projects/c3-components-docs/src/app/pages/docs/pages/file-displayer/components/example-display-list/example-display-list.component.ts
function ExampleDisplayListComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "span");
    \u0275\u0275text(2, "Mime Type");
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
}
function ExampleDisplayListComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "span");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const file_r1 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(file_r1.type);
  }
}
var _ExampleDisplayListComponent = class _ExampleDisplayListComponent {
  constructor() {
    this.files = signal(crabbyImgs, ...ngDevMode ? [{ debugName: "files" }] : []);
    this.config = signal(configDemo, ...ngDevMode ? [{ debugName: "config" }] : []);
    this.displayFn = signal((file) => file.metadata ? file.metadata["originalName"] : file.name, ...ngDevMode ? [{ debugName: "displayFn" }] : []);
    this.columns = signal(["icon", "name", "examples", "date"], ...ngDevMode ? [{ debugName: "columns" }] : []);
  }
};
_ExampleDisplayListComponent.\u0275fac = function ExampleDisplayListComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ExampleDisplayListComponent)();
};
_ExampleDisplayListComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ExampleDisplayListComponent, selectors: [["c3-example-display-list"]], decls: 4, vars: 4, consts: [[3, "files", "config", "displayFn", "columns"], ["c3FileDisplayListColumnDef", "examples"], [4, "c3FileDisplayListHeaderCellDef"], [4, "c3FileDisplayListCellDef"]], template: function ExampleDisplayListComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "c3-file-display-list", 0);
    \u0275\u0275elementContainerStart(1, 1);
    \u0275\u0275template(2, ExampleDisplayListComponent_ng_container_2_Template, 3, 0, "ng-container", 2)(3, ExampleDisplayListComponent_ng_container_3_Template, 3, 1, "ng-container", 3);
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("files", ctx.files())("config", ctx.config())("displayFn", ctx.displayFn())("columns", ctx.columns());
  }
}, dependencies: [C3FileDisplayerModule, C3FileDisplayListComponent, C3FileDisplayListColumnDefDirective, C3FileDisplayListHeaderCellDefDirective, C3FileDisplayListCellDefDirective], styles: ["\n\n[_nghost-%COMP%] {\n  display: block;\n}\n/*# sourceMappingURL=example-display-list.component.css.map */"] });
var ExampleDisplayListComponent = _ExampleDisplayListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExampleDisplayListComponent, [{
    type: Component,
    args: [{ selector: "c3-example-display-list", imports: [C3FileDisplayerModule], template: '<c3-file-display-list [files]="files()" [config]="config()" [displayFn]="displayFn()" [columns]="columns()">\n  <ng-container c3FileDisplayListColumnDef="examples">\n    <ng-container *c3FileDisplayListHeaderCellDef>\n      <span>Mime Type</span>\n    </ng-container>\n    <ng-container *c3FileDisplayListCellDef="let file">\n      <span>{{ file.type }}</span>\n    </ng-container>\n  </ng-container>\n</c3-file-display-list>\n', styles: ["/* projects/c3-components-docs/src/app/pages/docs/pages/file-displayer/components/example-display-list/example-display-list.component.scss */\n:host {\n  display: block;\n}\n/*# sourceMappingURL=example-display-list.component.css.map */\n"] }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ExampleDisplayListComponent, { className: "ExampleDisplayListComponent", filePath: "projects/c3-components-docs/src/app/pages/docs/pages/file-displayer/components/example-display-list/example-display-list.component.ts", lineNumber: 12 });
})();

// projects/c3-components-docs/src/app/pages/docs/pages/file-displayer/pages/examples/examples.component.ts
var _c03 = () => ({});
var _ExamplesComponent = class _ExamplesComponent {
};
_ExamplesComponent.\u0275fac = function ExamplesComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ExamplesComponent)();
};
_ExamplesComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ExamplesComponent, selectors: [["c3-examples"]], decls: 49, vars: 14, consts: [[1, "my-4"], [1, "mb-1", "px-4", "pb-2"], ["title", ""], ["label", "TypeScript"], ["highlight-js", "", "lang", "typescript", 3, "options"], ["label", "HTML"], ["highlight-js", "", "lang", "html", 3, "options"], ["example", ""], ["label", "CrabbyImg.ts"]], template: function ExamplesComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "p", 0);
    \u0275\u0275text(1, "Prebuild component for display files in list or grid");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "example-viewer", 1)(3, "h4", 2);
    \u0275\u0275text(4, "Example display list component with custom columns");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "c3-example-viewer-tab", 3)(6, "div")(7, "textarea", 4);
    \u0275\u0275text(8, "import { CommonModule } from '@angular/common';\nimport { Component, signal } from '@angular/core';\nimport {\n  crabbyImgs,\n  configDemo,\n} from 'projects/c3-components-docs/src/app/files-demo';\nimport { C3FileDisplayerModule } from 'c3-components';\n\n@Component({\n  selector: 'c3-example-display-list',\n  standalone: true,\n  imports: [CommonModule, C3FileDisplayerModule],\n  templateUrl: './example-display-list.component.html',\n  styleUrl: './example-display-list.component.scss',\n})\nexport class ExampleDisplayListComponent {\n  public readonly files = signal(crabbyImgs);\n  public readonly config = signal(configDemo);\n  public readonly columns = signal(['icon', 'name', 'date', 'type']);\n}\n      ");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(9, "c3-example-viewer-tab", 5)(10, "div")(11, "textarea", 6);
    \u0275\u0275text(12, '<c3-file-display-list [files]="files()" [config]="config()" [columns]="columns()">\n  <ng-container c3FileDisplayListColumnDef="type">\n    <div *c3FileDisplayListHeaderCellDef>\n      <span>Type de fichier</span>\n    </div>\n    <div *c3FileDisplayListCellDef="let file">\n      <span>{');
    \u0275\u0275text(13, "{");
    \u0275\u0275text(14, " file.type }");
    \u0275\u0275text(15, "}");
    \u0275\u0275text(16, "</span>\n    </div>\n  </ng-container>\n</c3-file-display-list>\n      ");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementContainerStart(17, 7);
    \u0275\u0275element(18, "c3-example-display-list");
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(19, "example-viewer", 1)(20, "h4", 2);
    \u0275\u0275text(21, "Example display list component (default)");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(22, "c3-example-viewer-tab", 3)(23, "div")(24, "textarea", 4);
    \u0275\u0275text(25, "import { CommonModule } from '@angular/common';\nimport { Component, signal } from '@angular/core';\nimport {\n  crabbyImgs,\n  configDemo,\n} from 'projects/c3-components-docs/src/app/files-demo';\nimport { C3FileDisplayerModule } from 'c3-components';\n\n@Component({\n  selector: 'c3-example-display-list',\n  standalone: true,\n  imports: [CommonModule, C3FileDisplayerModule],\n  templateUrl: './example-display-list.component.html',\n  styleUrl: './example-display-list.component.scss',\n})\nexport class ExampleDisplayListComponent {\n  public readonly files = signal(crabbyImgs);\n  public readonly config = signal(configDemo);\n}\n      ");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(26, "c3-example-viewer-tab", 5)(27, "div")(28, "textarea", 6);
    \u0275\u0275text(29, '<c3-file-display-list [files]="files()" [config]="config()" />\n      ');
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(30, "c3-example-viewer-tab", 8)(31, "div")(32, "textarea", 4);
    \u0275\u0275text(33, "import {\n  C3FileViewerConfig,\n  FileMetadata\n} from 'c3-components';\n\nexport const crabbyImgs: Array<FileMetadata> = [\n  {\n    name: 'Crabby - 1',\n    type: 'image/png',\n    location: 'img/crabby-1.png',\n    lastModified: new Date(),\n  },\n  {\n    name: 'Crabby - 2',\n    type: 'image/jpeg',\n    location: 'img/crabby-2.jpeg',\n    lastModified: new Date(),\n  },\n  {\n    name: 'Crabby - 3',\n    type: 'image/png',\n    location: 'img/crabby-3.png',\n    lastModified: new Date(),\n  },\n  {\n    name: 'Crabby - 4',\n    type: 'image/png',\n    location: 'img/crabby-4.png',\n    lastModified: new Date(),\n  },\n  {\n    name: 'Crabby - 5',\n    type: 'image/png',\n    location: 'img/crabby-5.png',\n  },\n  {\n    name: 'Crabby - 6',\n    type: 'image/png',\n    location: 'img/crabby-6.png',\n  },\n];\n\nexport const configDemo: C3FileViewerConfig = {\n  btnContainerClass: 'other',\n  btnClass: 'btn btn-hover-primary px-1',\n  btnSubClass: 'material-icons font-size-xl',\n  zoomFactor: 0.1,\n  wheelZoom: true,\n  allowFullscreen: true,\n  allowKeyboardNavigation: true,\n  height: '640px',\n  btnShow: {\n    zoomIn: true,\n    zoomOut: true,\n    rotateClockwise: true,\n    rotateCounterClockwise: true,\n    next: false,\n    prev: false,\n    reset: true,\n  },\n  btnIcons: {\n    next: {\n      text: 'navigate_next',\n    },\n    prev: {\n      text: 'navigate_before',\n    },\n  },\n  customBtns: [],\n};\n      ");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementContainerStart(34, 7);
    \u0275\u0275element(35, "c3-example-display-grid");
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(36, "example-viewer", 1)(37, "h4", 2);
    \u0275\u0275text(38, "Example display grid component");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(39, "c3-example-viewer-tab", 3)(40, "div")(41, "textarea", 4);
    \u0275\u0275text(42, "import { CommonModule } from '@angular/common';\nimport { Component, signal } from '@angular/core';\nimport {\n  configDemo,\n  crabbyImgs,\n} from 'projects/c3-components-docs/src/app/files-demo';\nimport { C3FileDisplayerModule } from 'c3-components';\n\n@Component({\n  selector: 'c3-example-display-grid',\n  standalone: true,\n  imports: [CommonModule, C3FileDisplayerModule],\n  templateUrl: './example-display-grid.component.html',\n  styleUrl: './example-display-grid.component.scss',\n})\nexport class ExampleDisplayGridComponent {\n  public readonly files = signal(crabbyImgs);\n  public readonly config = signal(configDemo);\n}\n      ");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(43, "c3-example-viewer-tab", 5)(44, "div")(45, "textarea", 6);
    \u0275\u0275text(46, '<c3-file-display-grid [files]="files()" [config]="config()" />\n      ');
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementContainerStart(47, 7);
    \u0275\u0275element(48, "c3-example-display-list");
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance(7);
    \u0275\u0275property("options", \u0275\u0275pureFunction0(7, _c03));
    \u0275\u0275advance(4);
    \u0275\u0275property("options", \u0275\u0275pureFunction0(8, _c03));
    \u0275\u0275advance(13);
    \u0275\u0275property("options", \u0275\u0275pureFunction0(9, _c03));
    \u0275\u0275advance(4);
    \u0275\u0275property("options", \u0275\u0275pureFunction0(10, _c03));
    \u0275\u0275advance(4);
    \u0275\u0275property("options", \u0275\u0275pureFunction0(11, _c03));
    \u0275\u0275advance(9);
    \u0275\u0275property("options", \u0275\u0275pureFunction0(12, _c03));
    \u0275\u0275advance(4);
    \u0275\u0275property("options", \u0275\u0275pureFunction0(13, _c03));
  }
}, dependencies: [
  ExampleDisplayGridComponent,
  ExampleDisplayListComponent,
  ExampleViewerComponent,
  ExampleViewerTabComponent,
  HighlightJsDirective
], styles: ["\n\n[_nghost-%COMP%] {\n  display: block;\n}\n/*# sourceMappingURL=examples.component.css.map */"] });
var ExamplesComponent = _ExamplesComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExamplesComponent, [{
    type: Component,
    args: [{ selector: "c3-examples", imports: [
      ExampleDisplayGridComponent,
      ExampleDisplayListComponent,
      ExampleViewerComponent,
      ExampleViewerTabComponent,
      HighlightJsDirective
    ], template: `<p class="my-4">Prebuild component for display files in list or grid</p>

<example-viewer class="mb-1 px-4 pb-2">
  <h4 title>Example display list component with custom columns</h4>

  <c3-example-viewer-tab label="TypeScript">
    <div>
      <textarea highlight-js [options]="{}" lang="typescript">
import { CommonModule } from '@angular/common';
import { Component, signal } from '@angular/core';
import {
  crabbyImgs,
  configDemo,
} from 'projects/c3-components-docs/src/app/files-demo';
import { C3FileDisplayerModule } from 'c3-components';

@Component({
  selector: 'c3-example-display-list',
  standalone: true,
  imports: [CommonModule, C3FileDisplayerModule],
  templateUrl: './example-display-list.component.html',
  styleUrl: './example-display-list.component.scss',
})
export class ExampleDisplayListComponent {
  public readonly files = signal(crabbyImgs);
  public readonly config = signal(configDemo);
  public readonly columns = signal(['icon', 'name', 'date', 'type']);
}
      </textarea>
    </div>
  </c3-example-viewer-tab>

  <c3-example-viewer-tab label="HTML">
    <div>
      <textarea highlight-js [options]="{}" lang="html">
<c3-file-display-list [files]="files()" [config]="config()" [columns]="columns()">
  <ng-container c3FileDisplayListColumnDef="type">
    <div *c3FileDisplayListHeaderCellDef>
      <span>Type de fichier</span>
    </div>
    <div *c3FileDisplayListCellDef="let file">
      <span>&#123;&#123; file.type &#125;&#125;</span>
    </div>
  </ng-container>
</c3-file-display-list>
      </textarea>
    </div>
  </c3-example-viewer-tab>

  <ng-container example>
    <c3-example-display-list></c3-example-display-list>
  </ng-container>
</example-viewer>

<example-viewer class="mb-1 px-4 pb-2">
  <h4 title>Example display list component (default)</h4>

  <c3-example-viewer-tab label="TypeScript">
    <div>
      <textarea highlight-js [options]="{}" lang="typescript">
import { CommonModule } from '@angular/common';
import { Component, signal } from '@angular/core';
import {
  crabbyImgs,
  configDemo,
} from 'projects/c3-components-docs/src/app/files-demo';
import { C3FileDisplayerModule } from 'c3-components';

@Component({
  selector: 'c3-example-display-list',
  standalone: true,
  imports: [CommonModule, C3FileDisplayerModule],
  templateUrl: './example-display-list.component.html',
  styleUrl: './example-display-list.component.scss',
})
export class ExampleDisplayListComponent {
  public readonly files = signal(crabbyImgs);
  public readonly config = signal(configDemo);
}
      </textarea>
    </div>
  </c3-example-viewer-tab>

  <c3-example-viewer-tab label="HTML">
    <div>
      <textarea highlight-js [options]="{}" lang="html">
<c3-file-display-list [files]="files()" [config]="config()" />
      </textarea>
    </div>
  </c3-example-viewer-tab>

  <c3-example-viewer-tab label="CrabbyImg.ts">
    <div>
      <textarea highlight-js [options]="{}" lang="typescript">
import {
  C3FileViewerConfig,
  FileMetadata
} from 'c3-components';

export const crabbyImgs: Array<FileMetadata> = [
  {
    name: 'Crabby - 1',
    type: 'image/png',
    location: 'img/crabby-1.png',
    lastModified: new Date(),
  },
  {
    name: 'Crabby - 2',
    type: 'image/jpeg',
    location: 'img/crabby-2.jpeg',
    lastModified: new Date(),
  },
  {
    name: 'Crabby - 3',
    type: 'image/png',
    location: 'img/crabby-3.png',
    lastModified: new Date(),
  },
  {
    name: 'Crabby - 4',
    type: 'image/png',
    location: 'img/crabby-4.png',
    lastModified: new Date(),
  },
  {
    name: 'Crabby - 5',
    type: 'image/png',
    location: 'img/crabby-5.png',
  },
  {
    name: 'Crabby - 6',
    type: 'image/png',
    location: 'img/crabby-6.png',
  },
];

export const configDemo: C3FileViewerConfig = {
  btnContainerClass: 'other',
  btnClass: 'btn btn-hover-primary px-1',
  btnSubClass: 'material-icons font-size-xl',
  zoomFactor: 0.1,
  wheelZoom: true,
  allowFullscreen: true,
  allowKeyboardNavigation: true,
  height: '640px',
  btnShow: {
    zoomIn: true,
    zoomOut: true,
    rotateClockwise: true,
    rotateCounterClockwise: true,
    next: false,
    prev: false,
    reset: true,
  },
  btnIcons: {
    next: {
      text: 'navigate_next',
    },
    prev: {
      text: 'navigate_before',
    },
  },
  customBtns: [],
};
      </textarea>
    </div>
  </c3-example-viewer-tab>

  <ng-container example>
    <c3-example-display-grid></c3-example-display-grid>
  </ng-container>
</example-viewer>

<example-viewer class="mb-1 px-4 pb-2">
  <h4 title>Example display grid component</h4>

  <c3-example-viewer-tab label="TypeScript">
    <div>
      <textarea highlight-js [options]="{}" lang="typescript">
import { CommonModule } from '@angular/common';
import { Component, signal } from '@angular/core';
import {
  configDemo,
  crabbyImgs,
} from 'projects/c3-components-docs/src/app/files-demo';
import { C3FileDisplayerModule } from 'c3-components';

@Component({
  selector: 'c3-example-display-grid',
  standalone: true,
  imports: [CommonModule, C3FileDisplayerModule],
  templateUrl: './example-display-grid.component.html',
  styleUrl: './example-display-grid.component.scss',
})
export class ExampleDisplayGridComponent {
  public readonly files = signal(crabbyImgs);
  public readonly config = signal(configDemo);
}
      </textarea>
    </div>
  </c3-example-viewer-tab>

  <c3-example-viewer-tab label="HTML">
    <div>
      <textarea highlight-js [options]="{}" lang="html">
<c3-file-display-grid [files]="files()" [config]="config()" />
      </textarea>
    </div>
  </c3-example-viewer-tab>

  <ng-container example>
    <c3-example-display-list></c3-example-display-list>
  </ng-container>
</example-viewer>
`, styles: ["/* projects/c3-components-docs/src/app/pages/docs/pages/file-displayer/pages/examples/examples.component.scss */\n:host {\n  display: block;\n}\n/*# sourceMappingURL=examples.component.css.map */\n"] }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ExamplesComponent, { className: "ExamplesComponent", filePath: "projects/c3-components-docs/src/app/pages/docs/pages/file-displayer/pages/examples/examples.component.ts", lineNumber: 21 });
})();

// projects/c3-components-docs/src/app/pages/docs/pages/file-displayer/file-displayer-routing.module.ts
var routes = [
  {
    path: "",
    component: ComponentNavComponent,
    children: [
      {
        path: "api",
        component: ApiComponent
      },
      {
        path: "examples",
        component: ExamplesComponent
      },
      {
        path: "**",
        redirectTo: "examples"
      }
    ],
    data: {
      links: [
        {
          url: "api",
          label: "Api"
        },
        {
          url: "examples",
          label: "Examples"
        }
      ]
    }
  }
];
var _FileDisplayerRoutingModule = class _FileDisplayerRoutingModule {
};
_FileDisplayerRoutingModule.\u0275fac = function FileDisplayerRoutingModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _FileDisplayerRoutingModule)();
};
_FileDisplayerRoutingModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _FileDisplayerRoutingModule });
_FileDisplayerRoutingModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({ imports: [RouterModule.forChild(routes), RouterModule] });
var FileDisplayerRoutingModule = _FileDisplayerRoutingModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileDisplayerRoutingModule, [{
    type: NgModule,
    args: [{
      imports: [RouterModule.forChild(routes)],
      exports: [RouterModule]
    }]
  }], null, null);
})();

// projects/c3-components-docs/src/app/pages/docs/pages/file-displayer/file-displayer.module.ts
var _FileDisplayerModule = class _FileDisplayerModule {
};
_FileDisplayerModule.\u0275fac = function FileDisplayerModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _FileDisplayerModule)();
};
_FileDisplayerModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _FileDisplayerModule });
_FileDisplayerModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({ imports: [FileDisplayerRoutingModule] });
var FileDisplayerModule = _FileDisplayerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileDisplayerModule, [{
    type: NgModule,
    args: [{
      declarations: [],
      imports: [FileDisplayerRoutingModule]
    }]
  }], null, null);
})();
export {
  FileDisplayerModule
};
//# sourceMappingURL=chunk-7FCDHHBR.js.map
